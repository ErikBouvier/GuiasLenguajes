=====================
Guía de Laravel by dM
=====================

Usaremos $ para describir los comandos que se usaran con usuario regular.

Usaremos # para describir los comandos que se usaran con superusuario.

================
¿Qué es Laravel?
================

Laravel es un framework de código abierto para desarrollar aplicaciones y
servicios web con PHP 5 y PHP 7. Su filosofía es desarrollar código PHP de forma
elegante y simple, evitando el "código espagueti". Fue creado en 2011 y tiene
una gran influencia de frameworks como Ruby on Rails, entre otros...

Gran parte de Laravel está formado por dependencias, especialmente de Symfony,
esto implica que el desarrollo de Laravel dependa también del desarrollo de sus
dependencias.

=======================
¿Como funciona Laravel?
=======================

Laravel utiliza el paradigma del "Modelo-Vista-Controlador"

1) Un usuario ingresa a una página o sistema web creado con Laravel, a ese
ingreso se le llama "solicitud" o "petición".

2) Esa "solicitud" o "petición" llega a un archivo llamado rutas, las rutas es
un archivo donde especificamos que rutas o direcciones url están disponible en
un sistema/página web.

Por ejemplo si yo tengo una página llamada misitio.com y puedo acceder a
"misitio.com/registro" donde muestra un formulario para registrarse, "/registro"
es una ruta. por tanto se debe definir en ese archivo donde están las rutas. si
intento acceder a "misitio.com/prueba" y me da error, eso quiere decir que esa
ruta no existe o no ha sido especificada en el archivo de rutas.

Si una ruta válida es visitada, el paso siguiente es ir a un controlador o una
vista, el ir a un controlador solo se hará si es necesario, el controlador es la
parte donde Laravel realiza operaciones con los datos, inserción, listar,
actualización de la base de datos, calculos, ejecutar funciones con los datos,
entre otros. En el controlador es donde está la lógica de un sistema/página web.

El controlador puede acceder al modelo, el modelo son las tablas de la base de
datos reflejadas en archivos php.

Entonces un controlador puede solicitar al modelo que le traiga todos los
usuarios registrados en el sistema para, el controlador los recibe de vuelta y
ahora puede mandarlos a una vista para que sean mostrados en una página simple.

La segunda opción es ir a una vista directamente, una vista es una pagina simple
donde se muestran textos, imagenes, videos, etc, sin interactuar con otros
elementos del sistema, sin consultas ni nada.

Otro elemento del paradigma de Laravel son los Middlewares, que no es mas que un
filtro. Imaginemos que tenemos un panel de administración del sistema, y no
queremos que todos los usuarios puedan acceder a ese panel, si no solo usuarios
con permisos adecuados, entonces ahí aparecen los middlewares y sus
funcionalidades. Las rutas y los controladores pueden acceder a los middlewares.

===============
Características
===============

-Sistema de ruteo, también RESTful
-Blade, Motor de plantillas
-Peticiones Fluent
-Eloquent ORM
-Basado en Composer
-Soporte para el caché
-Soporte para MVC
-Usa componentes de Symfony
-Adopta las especificaciones PSR-212​ y PSR-4

¿Qué es un ORM (Object Relational Mapping)?
===========================================

Un ORM es un modelo de programación que permite mapear las estructuras de una
base de datos relacional (SQL Server, Oracle, MySQL, etc.), en adelante RDBMS
(Relational Database Management System), sobre una estructura lógica de
entidades con el objeto de simplificar y acelerar el desarrollo de nuestras
aplicaciones.

Las estructuras de la base de datos relacional quedan vinculadas con las
entidades lógicas o base de datos virtual definida en el ORM, de tal modo que
las acciones CRUD (Create, Read, Update, Delete) a ejecutar sobre la base de
datos física se realizan de forma indirecta por medio del ORM.

¿Qué es el eloquent?
====================

Eloquent es el ORM que incluye Laravel para manejar de una forma fácil y
sencilla los procesos correspondientes al manejo de bases de datos en nuestro
proyecto, gracias a las funciones que provee podremos realizar complejas
consultas y peticiones de base de datos sin escribir una sola línea de código
SQL.

Viene incluido con Laravel y proporciona una implementación de ActiveRecord
hermosa y simple para trabajar con su base de datos. Cada tabla de la base de
datos tiene un "Modelo" correspondiente que se utiliza para interactuar con esa
tabla. Los modelos le permiten consultar datos en sus tablas, así como insertar
nuevos registros en la tabla.

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

=================================================================
Instalación de paquetes necesarios para la instalación de Laravel
=================================================================

**Importante** Esta guía fue probada en GNU/Linux Debian 9 Stretch
usando las siguientes versiones:

Instalar Apache:

# apt-get install apache2 

-----

Instalar PHP y extras para apache:

# apt-get install php7.0

# aptitude install php7.0-gd php7.0-mysql libapache2-mod-php7.0 php-zip php7.0-mbstring php7.0-xml php7.0-intl php-symfony-intl php7.0-libsodium

# aptitude install php-symfony-config php-symfony-dependency-injection php-symfony-expression-language php-symfony-yaml php-symfony-browser-kit php-libsodium php-symfony-http-kernel php-uuid

-----

Instalar Mysql para usarlo en un futuro como motor de base de datos:

# apt-get install mysql-server

================================
Para seguir necesitamos composer
================================

Composer es un manejador de dependencias, no un gestor de paquetes. Pero es
cierto que trata con paquetes y librerías, la instalación siempre es local para
cualquier proyecto, las librerías se instalan en un directorio por defecto
(normalmente es /vendor). Composer es capaz de instalar las librerías que
requiere tu proyecto con las versiones que necesiten. ¿Y si mis librerías
dependen de otras? También es capaz de resolver eso y descargar todo lo
necesario para que funcione y así quitarnos del dolor de cabeza de hacer todo
eso de forma manual.

=================================
¿Qué problemas resuelve Composer?
=================================

Tienes un proyecto que depende de ciertas librerías desarrolladas por terceros,
y a su vez, éstas librerías también dependen de otras (tú no tienes porqué
conocer estas librerías) lo que hace Composer en este caso es averiguar que
librerías deben instalarse; es decir, resuelve todas las dependencias indirectas
y descarga automáticamente la versión correcta de cada paquete.

Descargamos composer:

$ php -r "readfile('https://getcomposer.org/installer');" | php

El comando anterior nos descarga el fichero "composer.phar"

-----

Movemos composer a /usr/local/bin, lo cual nos permitirá que este disponible
desde donde sea que lo necesitemos:

# mv composer.phar /usr/local/bin/composer

-----

Comprobamos la instalación con el siguiente comando:

$ composer

======================
Instalación de Laravel
======================

Laravel utiliza Composer para manejar las dependencies. entonces, antes de usar
Laravel, hay que tener instalado Composer en nuestra máquina.

Primero descargamos el instalador de Laravel vía Composer

$ composer global require "laravel/installer=~1.1"

La salida de este comando:

Changed current directory to /home/user/.config/composer
./composer.json has been created
Loading composer repositories with package information
Updating dependencies (including require-dev)
Package operations: 10 installs, 0 updates, 0 removals
  - Installing symfony/process (v3.4.6): Downloading (100%)         
  - Installing psr/log (1.0.2): Downloading (100%)         
  - Installing symfony/debug (v3.4.6): Downloading (100%)         
  - Installing symfony/polyfill-mbstring (v1.7.0): Downloading (100%)         
  - Installing symfony/console (v3.4.6): Downloading (100%)         
  - Installing guzzlehttp/promises (v1.3.1): Downloading (100%)         
  - Installing psr/http-message (1.0.1): Downloading (100%)         
  - Installing guzzlehttp/psr7 (1.4.2): Downloading (100%)         
  - Installing guzzlehttp/guzzle (6.3.0): Downloading (100%)         
  - Installing laravel/installer (v1.3.4): Downloading (100%)         
symfony/polyfill-mbstring suggests installing ext-mbstring (For best performance)
symfony/console suggests installing symfony/event-dispatcher ()
symfony/console suggests installing symfony/lock ()
Writing lock file
Generating autoload files

Nos dice el directorio donde va a ser instalado laravel luego prosige con la
instalación.

Luego de la instalación, comprobamos la ruta donde está laravel con:

$ cd .config/composer/vendor/bin

Si navegamos bien hacia ese directorio, entonces seguimos, agregamos al final
del .bashrc lo siguiente:

PATH=$PATH:~/.config/composer/vendor/bin

Aplicamos los cambios con el siguiente comando:

$ source .bashrc

El primer comando el una comprobación corta, el segundo es completa y larga,
recomendado el primero.

Creamos un proyecto de laravel para probar:

$ laravel new nombre_del_proyecto

=================================================================
En la siguiente sección instalaremos Laravel en su última versión
=================================================================

**Importante** Esta guía fue probada usando la versión 7.2 de php,
Composer 1.6.3, Laravel Installer 2.0, Laravel Framework 5.6.11 en
GNU/Linux Debian 9 Stretch.

$ sudo apt-get install apt-transport-https lsb-release ca-certificates

$ sudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg

$ echo "deb https://packages.sury.org/php/ $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/php.list

$ sudo apt-get update

Si da problema con la firma, volver a ejecutar:

$ sudo wget -O /etc/apt/trusted.gpg.d/php.gpg https://packages.sury.org/php/apt.gpg
--2019-03-18 21:28:18--  https://packages.sury.org/php/apt.gpg

y probar de nuevo el update.

==================================
Instalación de paquetes necesarios
==================================

Buscamos la versión de php disponible en el repositorio.

$ aptitude search search php

-----

Instalamos la versión disponible del paquete

$ sudo apt-get install php7.2-cli

-----

Verificar la versión de php que se instaló.

$ php -v

-----

Instalar Apache:

# apt-get install apache2

-----

Instalar dependencias extras necesarias:

# aptitude install php7.2-gd php7.2-mysql libapache2-mod-php7.2 php-zip php7.2-mbstring php7.2-xml php7.2-intl

# aptitude install php-symfony-config php-symfony-dependency-injection php-symfony-expression-language php-symfony-yaml php-symfony-browser-kit php-libsodium php-symfony-http-kernel php-uuid

-----

Instalar Mysql para usarlo en un futuro como motor de base de datos

# apt-get install mysql-server

======================
Instalación de Laravel
======================

Instalar composer.

-----

Instalar Laravel

$ composer global require "laravel/installer"

-----

Luego de la instalación, comprobamos la ruta donde está laravel con:

$ cd .config/composer/vendor/bin

-----

Si navegamos bien hacia ese directorio, entonces seguimos, agregamos al final
del .bashrc lo siguiente:

PATH=$PATH:~/.config/composer/vendor/bin

-----

Aplicamos los cambios con el siguiente comando:

$ source .bashrc

El primer comando es para una comprobación corta, el segundo es completa y
larga, recomendado el primero.

-----

Creamos un proyecto de laravel para probar:

$ laravel new mysite

Luego de la generación del proyecto e instalación de dependendencias

-----

Entramos en el dirctorio del proyecto y corremos el servidor de desarrollo:

$ php artisan serve

Si corre sin problemas podemos visitar: localhost:8000/ y visualizar Laravel en
letras grandes.

======================================================
Intstalar y crear un proyecto de Laravel, vía composer

**Opción recomendada**
======================================================

Primero hay que instalar composer con los pasos descritos más arriba.

Luego, con el siguiente comando especificacoms la versión que queremos instalar:

$ composer create-project --prefer-dist laravel/laravel mysite "5.4.*"

Con el comando anterior lo que estamos declarando es que cree el proyecto
"mysite" y que se use la ultima actualización de la versión 5.4 de Laravel, que
es compatible con el php7.0 que está instalado.

Ahora vamos a correr el servidor local de desarrllo usando el script Artisan.

Este comando inicia el servidor de desarrllo en http://localhost:8000:

Entramos en el dirctorio del proyecto y corremos el servidor de desarrollo:

$ php artisan serve

Si corre sin problemas podemos visitar: localhost:8000/ y visualizar Laravel en
letras grandes.

Con el siguiente comando se instala la última versión disponible:

$ composer create-project --prefer-dist laravel/laravel mysite

Con esta opción Laravel quedará instalao dentro del proyecto creado, no estará
instalado de manera global en el sistema.

===========
Tips/Extras
===========

Primero que nada deberemos saber que cuando se ejecuta un proyecto este busca la
carpeta publica (public) la cual contiene un archivo index.php que se carga por
default el cual carga el proyecto.

-----

Para comprobar la versión de Laravel instalada entramos en el directorio de un
proyecto creado:

$ php artisan --version

-----

Para cambiar el puerto donde se esta sirviendo el proyecto:
	
$ php artisan serve --port=9000

-----

Para cambiar la ip y el puerto donde se esta sirviendo el proyecto:

$ php artisan serve --host=192.168.0.100 --port=8000

-----

Si se va a servir el proyecto por una url diferente a localhost, algunas cosas
como las imágenes puede ser que sigan siendo servidas por localhost por tanto se
puede configurar la variable APP_URL en el archivo .env que está oculto en el
directorio raíz del proyecto:

#APP_URL=http://localhost
APP_URL=http://192.168.0.100

Cuando se clona un proyecto de un repositorio, lo mas común es que se omita la
carpeta /vendor que contiene los paquetes/librerías requeridas por el proyecto,
entonces las instalamos con:

$ composer install

===================================
Estructura del proyecto con Laravel
===================================

Vamos a comentar los principales directorios de la estructura de Laravel para
ello me he ayudado de la documentación de la estructura en español de Laravel,
donde puedes encontrar información más detallada:

-app: Contiene los modelos, y el código base de nuestra aplicación, incluirá
los directorios Console, Http y Providers.

-app/Http/routes.php: para la definición de las rutas.

-app/Http/Controllers: Aquí será donde se definirán los controladores.

-app/config/app.php: Contiene configuración general de la aplicación.

-bootstrap: Contiene el archivo app.php que arranca el framework. Este directorio
también alberga un directorio de caché que contiene archivos generados por el
framework para la optimización del rendimiento, como los archivos de caché de
rutas y servicios. Normalmente, no debería necesitar modificar ningún archivo
dentro de este directorio.

-config: Como su nombre lo indica, contiene todos los archivos de configuración
de su aplicación. Es una gran idea leer todos estos archivos y familiarizarse
con todas las opciones disponibles.

-database: El directorio de la base de datos contiene las migraciones de la base
de datos, las fábricas de modelos y las semillas o seeds. Si lo desea, también
puede utilizar este directorio para almacenar una base de datos SQLite.

-resources/views: Contiene las vistas, donde usaremos el motor de plantillas
Blade. El directorio de recursos contiene sus vistas, así como archivos CSS o
JavaScript sin compilar, este directorio también aloja todos sus archivos de
idioma.

-public: Carpeta pública desde dónde se inicia el proceso de ejecución de una
aplicación Laravel.

El punto de entrada para todas las solicitudes a una aplicación de Laravel es el
archivo public/index.php. Todas las solicitudes son dirigidas a este archivo por
la configuración de su servidor web (Apache / Nginx). El archivo index.php no
contiene mucho código. Más bien, es un punto de partida para cargar el resto del
marco.

El archivo index.php carga la definición de autocargador generada por Composer y
luego recupera una instancia de la aplicación Laravel desde bootstrap/app.php.

-routes: El directorio de rutas contiene todas las definiciones de ruta para su
aplicación. De forma predeterminada, se incluyen varios archivos de ruta con
Laravel: web.php, api.php, console.php y channels.php.

-routes/web.php: Contiene rutas que RouteServiceProvider coloca en el grupo de
middleware web, que proporciona el estado de la sesión, la protección CSRF y el
cifrado de cookies.  Si su aplicación no ofrece una API RESTful sin estado, es
probable que todas sus rutas estén definidas en el archivo web.php.

-routes/api.php: Contiene rutas que RouteServiceProvider coloca en el grupo de
middleware api. Estas rutas están destinadas a ser sin estado, por lo que las
solicitudes que ingresan a la aplicación a través de estas rutas deben
autenticarse mediante tokens y no tendrán acceso al estado de la sesión.

-routes/console.php: Es donde puedes definir todos tus comandos de consola
basados ​​en el cierre. Cada cierre está vinculado a una instancia de comando, lo
que permite un enfoque simple para interactuar con los métodos de I/O de cada
comando. Aunque este archivo no define rutas HTTP, define puntos de entrada
(rutas) basados ​​en la consola en su aplicación.

-routes/channels.php: Es donde puede registrar todos los canales de transmisión
de eventos que admite su aplicación.

-storage: El directorio de almacenamiento contiene sus registros, plantillas
Blade compiladas, sesiones basadas en archivos, cachés de archivos y otros
archivos generados por el framework. Este directorio está segregado en
los directorios app, framework y logs. El directorio app se puede utilizar para
almacenar cualquier archivo generado por su aplicación. El directorio framewok
se utiliza para almacenar cachés y archivos generados por el marco. Finalmente,
el directorio logs contiene los archivos de registro de su aplicación.

-storage/app/public: Se puede utilizar para almacenar archivos generados por el
usuario, como los avatares de perfil, que deberían ser de acceso público. Debe
crear un enlace simbólico en public/storage que apunte a este directorio. Puede
crear el enlace usando el comando de artisan php artisan storage:link

-vendor: Contiene los paquetes y dependencias de Composer instaladas.

================================================
Actualizar proyectos de Laravel luego de un pull
================================================

$ composer install

$ npm install

$ npm run dev

$ composer dumpautoload

$ php artisan migrate

===========================
Limpiar la cache en Laravel
===========================

Ejecute el siguiente comando para borrar la memoria caché de la aplicación
Laravel.

$ php artisan cache:clear

==============================================================
Eliminar rastros de la configuración de un proyecto en Laravel
==============================================================

Elimina rastros de la configuración del sistema y las carga de nuevo, es decir,
es como si borraras los .pyc en proyectos de python.

$ php artisan config:cache

================================================
Borrar la caché de ruta de su aplicación Laravel
================================================

Para borrar el caché de ruta de su aplicación Laravel, ejecute el siguiente
comando

$ php artisan route:clear

=============================
Borrar caché de configuración
=============================

Puede usar config:clear para borrar la caché de configuración de la aplicación
Laravel.

$ php artisan config:clear

=================================
Borrar caché de vistas compiladas
=================================

Además, es posible que deba borrar los archivos de vista compilados de su
aplicación Laravel. Para borrar los archivos de vista compilados, ejecute el
siguiente comando desde la terminal.

$ php artisan view:clear

=================================
Configurar Laravel con postgresql
=================================

Configurar base de datos de postgresql en el archivo .env:

DB_CONNECTION=pgsql
DB_HOST=localhost
DB_PORT=5432
DB_DATABASE=nombre_base_de_datos
DB_USERNAME=usuario_base_de_datos
DB_PASSWORD=contrasena_base_de_datos

=============================
Configurar Laravel con sqlite
=============================

1) Instalar el paquete de sqlite para php, dependiendo de la versión de php que
tengamos instalada.

# apt install php7.3-sqlite3

2) Crear un archivo database.sqlite en la ruta my_project/database.

my_project/database$ touch database.sqlite

3) Configurar el fichero .env, debemos poner la ruta absoluta de la db.

DB_CONNECTION=sqlite
APP_URL=http://127.0.0.1
DB_PORT=3306
DB_DATABASE=/home/user/my_project/database/database.sqlite
DB_USERNAME=homestead
DB_PASSWORD=secret

4) Una vez configurada el gestor de base de datos, realizamos las migraciones.

$ php artisan migrate

5) Levantar el servidor de desarrollo.

$ php artisan serve

====================================
Artisan CLI (Command Line Interface)
====================================

Artisan es el nombre de la interfaz de línea de comandos incluida con Laravel.
Proporciona una serie de comandos útiles para su uso mientras desarrolla su
aplicación.  Está impulsado por el poderoso componente de la Consola Symfony.

===========================
Comandos de artisan y otros
===========================

Para conocer el listado completo de los comandos disponibles ejecutamos en
consola, en el directorio raíz de un proyecto de Laravel.

$ php artisan list

Comando disponibles:

clear-compiled  Eliminar el archivo de clase compilado
db              Iniciar una nueva sesión de CLI de base de datos
down            Ponga la aplicación en modo de mantenimiento / demostración
dump-server     Inicie el servidor de volcado para recopilar información de volcado
env             Mostrar el entorno del actual del framework
help            Muestra ayuda para un comando
inspire         Muestra una cita inspiradora
list            Lista de comandos de artisan
migrate         Ejecute las migraciones de la base de datos
optimize        Almacenar en caché los archivos de arranque del framework
serve           Sirve la aplicación en el servidor de desarrollo PHP
test            Ejecute las pruebas de la aplicación
tinker          Interactuar con su aplicación
ui              Swap the front-end scaffolding for the application
up              Saque la aplicación del modo de mantenimiento

auditing
  auditing:audit-driver  Cree un nuevo controlador de auditoría
  auditing:install       Instale todos los recursos de auditoría

auth
  auth:clear-resets      Vacíe los tokens de restablecimiento de contraseña caducados

backup
  backup:clean           Elimine todas las copias de seguridad anteriores al número de días especificado en config.
  backup:list            Muestra una lista de todas las copias de seguridad.
  backup:monitor         Supervise el estado de todas las copias de seguridad.
  backup:run             Ejecute la copia de seguridad.

cache
  cache:clear            Vaciar la caché de la aplicación
  cache:forget           Eliminar un elemento de la caché
  cache:table            Crear una migración para la tabla de la base de datos de caché

config
  config:cache           Cree un archivo de caché para una carga de configuración más rápida
  config:clear           Eliminar el archivo de caché de configuración

countries
  countries:update       Actualizar todos los datos

db
  db:seed                Sembrar la base de datos con registros
  db:wipe                Eliminar todas las tablas, vistas y tipos

debugbar
  debugbar:clear         Borrar el almacenamiento de la barra de depuración

event
  event:cache            Descubrir y almacenar en caché los eventos y los oyentes de la aplicación.
  event:clear            Borrar todos los eventos y oyentes almacenados en caché
  event:generate         Genere los eventos y oyentes que faltan en función del registro
  event:list             Enumere los eventos y los oyentes de la aplicación

key
  key:generate           Establecer la clave de la aplicación

log-viewer
  log-viewer:check       Verifique todos los requisitos de LogViewer.
  log-viewer:clear       Borrar todos los archivos de registro generados
  log-viewer:publish     Publique todos los recursos y archivos de configuración de LogViewer
  log-viewer:stats       Muestra estadísticas de todos los registros.

make
  make:cast              Create a new custom Eloquent cast class
  make:channel           Create a new channel class
  make:command           Create a new Artisan command
  make:component         Create a new view component class
  make:controller        Create a new controller class
  make:event             Create a new event class
  make:exception         Create a new custom exception class
  make:export            Create a new export class
  make:factory           Create a new model factory
  make:import            Create a new import class
  make:job               Create a new job class
  make:listener          Create a new event listener class
  make:mail              Create a new email class
  make:middleware        Create a new middleware class
  make:migration         Create a new migration file
  make:model             Create a new Eloquent model class
  make:notification      Create a new notification class
  make:observer          Create a new observer class
  make:policy            Create a new policy class
  make:provider          Create a new service provider class
  make:request           Create a new form request class
  make:resource          Create a new resource
  make:rule              Create a new validation rule
  make:seeder            Create a new seeder class
  make:test              Create a new test class

migrate
  migrate:fresh          Elimine todas las tablas y vuelva a ejecutar todas las migraciones
  migrate:install        Crea el repositorio de migración
  migrate:refresh        Restablecer y volver a ejecutar todas las migraciones
  migrate:reset          Revertir todas las migraciones de bases de datos
  migrate:rollback       Revertir la última migración de la base de datos
  migrate:status         Muestra el estado de cada migración.

notifications
  notifications:table    Crea una migración para la tabla de notificaciones

optimize
  optimize:clear         Eliminar los archivos de arranque en caché

package
  package:discover       Reconstruir el manifiesto del paquete en caché

queue
  queue:batches-table    Create a migration for the batches database table
  queue:clear            Delete all of the jobs from the specified queue
  queue:failed           List all of the failed queue jobs
  queue:failed-table     Create a migration for the failed queue jobs database table
  queue:flush            Flush all of the failed queue jobs
  queue:forget           Delete a failed queue job
  queue:listen           Listen to a given queue
  queue:prune-batches    Prune stale entries from the batches database
  queue:restart          Restart queue worker daemons after their current job
  queue:retry            Retry a failed queue job
  queue:retry-batch      Retry the failed jobs for a batch
  queue:table            Create a migration for the queue jobs database table
  queue:work             Start processing jobs on the queue as a daemon

route
  route:cache            Cree un archivo de caché de ruta para un registro de ruta más rápido
  route:clear            Eliminar el archivo de caché de ruta
  route:list             Lista de todas las rutas registradas

schedule
  schedule:list          List the scheduled commands
  schedule:run           Run the scheduled commands
  schedule:test          Run a scheduled command
  schedule:work          Start the schedule worker

schema
  schema:dump            Volcar el esquema de base de datos dado

session
  session:table          Crear una migración para la tabla de la base de datos de la sesión

snapshot
  snapshot:cleanup       Specify how many snapshots to keep and delete the rest
  snapshot:create        Create a new snapshot.
  snapshot:delete        Delete a snapshot.
  snapshot:list          List all the snapshots.
  snapshot:load          Load up a snapshot.

storage
  storage:link           Create the symbolic links configured for the application

stub
  stub:publish           Publish all stubs that are available for customization

ui
  ui:auth                Scaffold basic login and registration views and routes
  ui:controllers         Scaffold the authentication controllers

vendor
  vendor:publish         Publish any publishable assets from vendor packages

view
  view:cache             Compile todas las plantillas Blade de la aplicación
  view:clear             Borrar todos los archivos de vista compilados

-----

Sacar la aplicación del modo de mantenimiento.

$ php artisan up

-----

Poner la aplicación en modo de mantenimiento.

$ php artisan down

-----

Para ver el listado completo de rutas, Como resultado nos mostrará un listado de
todas las rutas de la aplicación con la información sobre el método HTTP, la
URI, la acción, el nombre y los middleware definidos para cada ruta, con lo
cual, entre otras cosas, podemos verificar que todas las rutas de nuestra
aplicación están bien definidas.

php artisan route:list

-----

Mismo que el anterior pero más compacta la información.

$ php artisan route:list -c

-----

Restablecer y volver a ejecutar todas las migraciones

$ php artisan migrate:refresh

-----

Omite los métodos down o los rollbacks eliminando todas las tablas para luego
ejecutar los métodos up.

$ php artisan migrate:fresh

-----

Actualice la base de datos y ejecute todas las semillas de la base de datos.

$ php artisan migrate:refresh --seed

-----

Quitar todas las tablas, migrar y cargar la base de datos con las semillas

$ php migrate artisan: fresh

$ php artisan migrate: fresh --seed

-----

El comando dump-autoload actualiza la información del cargador automático de
clases. Este comando es útil cuando añades nuevas clases y no quieres ejecutar
el comando install o update.

$ composer dumpautoload

-----

Con este comando Laravel compilará todos los paquetes que se encuentran en
node_modules y unificará los archivos que se encuentran en el directorio
resources/js y resources/sass a los archivos app.js y app.css respectivamente.

$ npm run dev

-----

Con este comando Laravel compilará todos los paquetes que se encuentran en
node_modules y unificará los archivos que se encuentran en el directorio
resources/js y resources/sass a los archivos app.js y app.css respectivamente.

$ npm run prod

Diferencias entre run dev y run prod
====================================

run dev: Compilar para desarrollo, los archivos resultantes mantienen el código
fuente desminificados. Las herramientas usadas en el navegador identifican los
objetos y componentes para poder depurar el código.

run prod -> compilar para producción, los archivos resultantes estan
minificados. Las herramientas de desarrollo usadas en el navegador no pueden
acceder a los componentes u objetos por lo que es complicado poder interactuar
con ellos a través del navegador.

-----

npm run dev combina todos sus componentes de Vue y otros archivos JavaScript en
un archivo combinado compatible con el navegador.

npm run watch hace lo mismo, pero luego permanece activo y "observa" las
actualizaciones de sus archivos .vue y .js. Si detecta un cambio, reconstruirá
el archivo compatible con el navegador para que pueda actualizar la página.

$ npm run watch

===============
Seed y Seeders
===============

Una manera de cargar datos en la base de datos es utilizando los Seeders de
Laravel.

Laravel incluye un método simple para sembrar su base de datos con datos de
prueba utilizando clases semilla (Seed). Todas las clases de semillas se
almacenan en el directorio database/seeds. Las clases de semillas pueden tener
el nombre que desee, pero probablemente deberían seguir alguna convención
razonable, como nombretablaSeeder, etc. De manera predeterminada, se define una
clase DatabaseSeeder para usted. Desde esta clase, puede utilizar el método de
llamada para ejecutar otras clases semilla, lo que le permite controlar el orden
de siembra.

Aplicar un seeder específico
============================

Se puede aplicar un seeder de maner individual con el siguiente comando:

$ php artisan db:seed --class NombreDelSeeder

Crear un seeder
===============

$ php artisan make:seeder CategoriesSeeder

Esto nos creará un archivo en la carpeta database/seeds/ que tendrá el nombre
que le demos en el comando.

Así se ve CategoriesSeeder.php

<?php

use Illuminate\Database\Seeder;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}

Con esto ya tenemos el archivo pero no es todo lo que necesitamos para poder
trabajar con datos autogenerados, para ello usaremos un componente llamado Faker
el cual se encargará de generar estos datos, Faker viene instalado por defeto
en Laravel.

Vamos al archivo CategoriesSeeder y dentro podremos observer que se encuentra
una función llamada run() que es donde nosotros vamos a usar Faker para poblar
la base de datos o la tabla específica, ahora bien antes de todo debemos agregar
la clase de Faker a nuestro Seeder, para esto agregamos al inicio del archivo la
linea:

use Faker\Factory as Faker;

Quedaría el archivo así:

<?php

use Illuminate\Database\Seeder;
use Faker\Factory as Faker;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        //
    }
}

Ahora crearemos una variable llamada $faker que nos servira para poblar la base
de datos, ahora bien usando la clase DB, si bien dentro del ejemplo queremos
crear 50 categorías vamos a crear un for para que ejecute nuestro código de
inserción 50 veces y el componente de Faker en cada pasada cambiará los valores
del registro que se va a agregar, quedando de esta forma:

$faker = Faker::create();
for ($i=0; $i < 50; $i++) {
    \DB::table('categories')->insert(array(
           'name' => $faker->firstNameFemale,
           'created_at' => date('Y-m-d H:m:s'),
           'updated_at' => date('Y-m-d H:m:s')
    ));
}

Creamos nuestro objeto Faker, el cual puede generar información falsa para
nuestra base de datos y ahora usamos la clase DB el método table para llamar la
tabla donde se va a insertar la información y se le concatena el método insert()
el cual recibe por parametro un arreglo clave => valor con los campos de la tabla.

Faker tiene muchas variedades de datos, los cuales podemos consultar en su
Repositorio de Github así como su uso básico.

En este ejemplo usamos una propiedad que se llama firstNameFemale para darle
nombre a las categorías y la propiedad.

y si lo agregamos al ejemplo queda así:

<?php

use Illuminate\Database\Seeder;
use Faker\Factory as Faker;

class CategoriesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        $faker = Faker::create();
        for ($i=0; $i < 50; $i++) {
            \DB::table('categories')->insert(array(
                   'name' => $faker->firstNameFemale,
                   'created_at' => date('Y-m-d H:m:s'),
                   'updated_at' => date('Y-m-d H:m:s')
            ));
        }
    }
}

Y ahora lo que sigue es abrir un archivo llamado DatabaseSeeder.php, en este
archivo se mandan a llamar todos los seeders en el orden que los necesitemos, en
este archivo se agregará la linea:

$this->call('PastelesSeeder');

Quedano así:

<?php

use Illuminate\Database\Seeder;

class DatabaseSeeder extends Seeder
{
    /**
     * Seed the application's database.
     *
     * @return void
     */
    public function run()
    {
        // $this->call(UsersTableSeeder::class);
        $this->call('CategoriesSeeder');
    }
}

Ahora para ejecutar el los seeders:

$ php artisan db:seed

Solo resta revisar los datos guardados en la tabla para comprobar que haya
funcionado.

Se pueden consultar las demás opciones disponibles de Faker para generar
diferentes tipos de datos desde:

https://github.com/fzaninotto/Faker#basic-usage

=============================================
Descargue y cargue bases de datos rápidamente
=============================================

Usando el paquete laravel-db-snapshots

Disponible desde > https://github.com/spatie/laravel-db-snapshots

Este paquete proporciona comandos Artisan para descargar y cargar rápidamente
bases de datos en una aplicación de Laravel.

Crear un dump

$ php artisan snapshot:create my-first-dump

Nos creara un archivo "my-first-dump.sql" en la ruta project/database/snapshots

-----

Crear otro dump

$ php artisan snapshot:create my-second-dump

-----

Cargar el primer dump

$ php artisan snapshot:load my-first-dump

-----

Cargar el último dump

$ php artisan snapshot:load --latest

-----

Listar todas las snapshots

$ php artisan snapshot:list

====================================
Estructura de un proyecto en Laravel
====================================

Nota: Probado en Laravel 5

Todos los proyectos nuevos en Laravel 5.1 tienen la siguiente estructura de
directorios:

app/
bootstrap/
config/
database/
public/
resources/
storage/
tests/
vendor/
.env
.env.example
.gitattributes
.gitignore
artisan
composer.json
composer.lock
gulpfile.js
package.json
phpspec.yml
phpunit.xml
readme.md
server.php

A continuación describiremos los directorios y archivos más importantes para que
nos ayuden a entender más el funcionamiento del framework.

=================
El directorio app
=================

App es usado para ofrecer un hogar por defecto a todo el código personal de tu
proyecto. Eso incluye clases que puedan ofrecer funcionalidad a la aplicación,
archivos de configuración y más. Es considerado el directorio más importante de
nuestro proyecto ya que es en el que más trabajaremos.

El directorio app tiene a su vez otros subdirectorios importantes pero uno de
los más utilizados es el directorio Http en el cuál ubicaremos nuestros
Controllers, Middlewares y Requestsen sus carpetas correspondientes, además
dentro del subdirectorio Http encontremos también el archivo routes.php donde
escribiremos las rutas de la aplicación.

A nivel de la raíz del directorio app encontraremos el modelo User.php, los
modelos comunmente se ubicarán a nivel de la raíz de la carpeta app aunque igual
es posible estructurarlos de la forma que queramos, por ejemplo, en una carpeta
llamada Models.

====================
El directorio config
====================

La configuración tanto para el framework como para tu aplicación se mantiene en
este directorio. La configuración de Laravel existe como un conjunto de archivos
PHP que contienen matrices clave-valor. Entre los archivos más usados del
directorio config se encuentran:

app.php : En este archivo nos puede interesar configurar el lenguaje de nuestra
aplicación, la zona horaria, los providers y aliases de las clases más comunes.

database.php : En este archivo podemos configurar principalmente el motor de
base de datos al cuál deseamos conectarnos.

======================
El directorio database
======================

Aquí se encontraran los archivos relacionados con el manejo de la base de datos.

Dentro de este directorio se encuentran los subdirectorios:

factories : Aquí escribiremos nuestros model factories.

migrations : Todas las migraciones que creamos se ubican en este subdirectorio.

seeds : Contiene todas las clases de tipo seed.

====================
El directorio public
====================

Dentro de este directorio colocaremos todos los recursos estáticos de nuestra
aplicación, es decir, archivos css, js, imágenes y fuentes.

Es recomendable crear una carpeta por cada tipo de recurso.

=======================
El directorio resources
=======================

Dentro de este directorio se encuentran los subdirectorios:

assets : Aquí se ubican todos los archivos less de nuestra aplicación (útil para
desarrolladores front-end).

lang : Aquí se encuentran todos los archivos de internacionalización, es decir,
los archivos para poder pasar nuestro proyecto de un idioma a otro.

Normalmente habrá una carpeta por cada idioma, ejemplo:
en : idioma inglés
es : idioma español

views : Aquí ubicaremos nuestras vistas en formato php o php.blade, es
recomendable crear una carpeta por cada controlador, además agregar una carpeta
templates para las plantillas. Una plantilla es una vista general, que tiene
segmentos que pueden ser reemplazados mediante la herencia de plantillas.

=====================
El directorio storage
=====================

Cuando Laravel necesita escribir algo en el disco, lo hace en el directorio
storage. Por este motivo, tu servidor web debe poder escribir en esta ubicación.
Aquí podemos encontrar otros directorios entre los cuales el más relevante es el
subdirectorio framework, es ahí donde se almacena el cache y las vistas
compiladas.

===================
El directorio tests
===================

Aquí escribiremos los archivos de pruebas que serán ejecutadas posteriormente
por phpunit.

==============================
El archivo .env y .env.example
==============================

El archivo .env no existe cuando instalamos laravel, en este archivo se
configurará el modo en que se ejecuta nuestra aplicación, por defecto será el
modo debug, además podemos configurar la conexión a la base de datos y la
conexión con el servidor de correo electronico. El archivo .env lo creamos
copiando el archivo .env.example y renombrando la copia como .env.

Por motivos de seguridad de la base de datos el archivo .env nunca se sube
cuando hacemos un push en nuestro repositorio. Es por eso que aparece escrito
dentro del archivo .gitignore en la raíz de nuestro proyecto.

=======================
El archivo package.json
=======================

Es el responsable de almacenar el nombre de las dependencias de node instaladas
catalogándolas principalmente en dos tipos: dependencias de desarrollo y
dependencias de la aplicación.

Al mirar dentro de este archivo, si bien hay algunas cosas que podemos reconocer
de manera inmediata, hay algunos valores y textos que es muy probable que no
sepamos que significan ni como llegaron ahí.

¿Qué es el package.json?
========================

De cierta forma, podemos considerar este package.json como un manifiesto de
nuestro proyecto.

Históricamente, Node ha trabajado con una herramienta para administrar paquetes
llamada npm. Esta herramienta, que normalmente se instala junto con Node, tiene
dos roles fundamentales:

-Manejar la publicación de un proyecto al registro público de npm (para que
otros puedan descargarlo y utilizarlo como dependencia en sus propios proyectos).

-Administrar las dependencias de tu proyecto.

Para esto, guarda un registro en un archivo llamado, justamente, package.json.

Dentro de este archivo se definen y manejan características como:

-Nombre de tu proyecto.
-Versión.
-Dependencias.
-Repositorio.
-Autores.
-Licencia.

A través de este archivo, finalmente, se puede garantizar la integridad del
proyecto. Es decir, podemos asegurar que quienes tengan una copia del mismo,
podrán acceder a las mismas propiedades y sincronizar entre múltiples partes
cada vez que decidan hacer un cambio. De cierta forma, podemos considerar este
package.json como un manifiesto de nuestro proyecto.

Por ejemplo, consideremos el siguiente escenario:

Dos personas están trabajando en el mismo proyecto, con copias independientes en
cada uno de sus equipos. El primero de ellos determina que para completar la
nueva funcionalidad, va a necesitar implementar una nueva librería al proyecto.

Antiguamente, sin manejo de dependencias, era necesario hacer una de dos cosas:

-Incluir la librería (1 o múltiples archivo(s)) manualmente en el directorio del
proyecto, potencialmente aumentando el peso del proyecto de manera considerable.

-No incluir la librería, pero comunicarle a cada persona que obtuviera una copia
del mismo que antes de trabajar en el proyecto necesitaría instalar esta nueva
dependencia (buena forma de hacer nuevos amigos, poco óptimo en términos de
tiempo).

Con el uso de administradores de dependencias, ya estos pasos no son necesarios.
Ahora cada persona que decida obtener una copia del proyecto, desde ahora al
final de los tiempos, puede instalar todas y cada una de las dependencias que
tengamos declaradas en este “manifiesto” sin la necesidad de incluir una copia
de éstas en ningún otro lado más que ahí.

Cabe mencionar que si bien muchas características del package.json parecieran
ser específicas para proyectos publicados en el registro de npm (como librerías)
también aplican para proyectos cuya finalidad no es ser publicados en ningún
registro (como por ejemplo aplicaciones Web o móviles, juegos y otros), pero que
si se benefician de las utilidades relacionadas a la administración de
dependencias.

¿Cómo crearlo?
==============

Antes de crear un package.json, hay solo una regla a tener en consideración: El
archivo debe ser un JSON de formato válido (no puede ser un objeto literal de JS
exportado desde un archivo), con todas las especificaciones que esto implica
(por ejemplo, cada key debe tener comillas dobles, solo ciertos valores son
válidos, etc.)

Para crearlo, hay 2 formas: hacerlo de forma manual o hacerlo de forma
automática:

===================================
Creando un package.json manualmente
===================================

Si bien es recomendable usar alguno de los asistentes para crear el archivo de
forma automática, en caso de que necesitemos hacerlo de forma manual, es solo
cosa de crear un archivo llamado package.json en la raíz del proyecto e incluir,
como mínimo, la siguiente información:

name.
version.

=======================================
Creando un package.json automáticamente
=======================================

Es la forma más rápida de hacerlo, ya que tanto npm como yarn incluyen un
asistente que nos permite crear un package.json con un solo comando:

$ npm init

El asistente nos hará algunas preguntas para definir la información del proyecto
(nombre, version, archivo de entrada, licencia y repositorio entre otros).

Fuente
======

-https://medium.com/noders/t%C3%BA-yo-y-package-json-9553929fb2e3

====
Yarn
====

Es una herramienta de administración de paquetes para Node llamada. Su
funcionamiento, al menos en cuanto al uso del package.json, es prácticamente
igual.

========================
El archivo composer.json
========================

Cuando comenzamos un proyecto tenemos a la mano al archivo composer.json, aquí
encontramos una lista con los paquetes y versiones que usará nuestra aplicación,
pero en la medida que avanzamos vemos que nos aparece un archivo llamado
composer.lock y por eso estamos aquí. Este archivo (composer.json) es un plano
inicial y breve, es una lista jerárquica de dependencias y aplicaciones. Cuando
comenzamos no tenemos un archivo composer.lock, este aparece en el momento que
ejecutamos el comando composer install. En otras palabras, instalamos los
paquetes y el misterioso archivo composer.lock nace y tiene vida.

========================
El archivo composer.lock
========================

Revelemos el misterio, en composer.json tenemos una breve lista con las
versiones aproximadas de dependencia que Composer debe instalar, y el archivo
composer.lock tiene el registro exacto de las versiones de dependencia que se
han instalado.

Si fuiste a mirar el archivo composer.lock habrás notado que es un super
archivo, y eso se debe a que tiene item a item la versión precisa que se instaló
cuando Composer siguió las instrucciones de archivo composer.json. Este archivo
también realiza un seguimiento de todas las versiones de las dependencias de sus
dependencias. Tienes todo aquí, dependencias de dependencias de dependencia que
a su vez puede tener dependencias... Bueno, entiendes la idea.

Todo, absolutamente todo tu sistema a nivel jerárquico de dependencias tendrá
sus versiones en el archivo composer.lock.

Lo que puedes estarte preguntando es ¿para que me sirve?... Y esto es bastante
simple. Si eliminas a la carpeta vendor a su vez estarás elimimando todos los
paquetes y dependencias. Entonces no te preocupas, solo ejecutas el comando
composer install y composer verá que tienes un archivo llamado composer.lock.
Entonces en lugar de encontrar versiones compatibles de su dependencias para
completar el archivo composer.json, él instalará la versión exacta de su
dependencias como se define en el archivo composer.lock.

Esto significa que tenemos la versión exacta de nuestras dependencias que
teníamos instaladas antes borrar la carpeta vendor. Y eso si resulta bastante
útil.

Otra pregunta, ¿qué causaría que el archivo composer.lock cambie?

Este archivo cambia si ejecutas el comando composer update y no recomiendo
hacerlo a cada rato, debes usar composer install para instalar tu nuevo paquete
sin actualizar las versiones de tus otros paquetes. Esto sería mucho más seguro
y evitamos fallas por actualizar nuevos paquetes y dependencias.

============================================================================
Añadir/Agregar e instalar nuevos paquetes en nuestra aplicación vía composer
============================================================================

Con este comando el paquete se agreagará a composer.json y composer.lock y se
instalara.

$ composer require laravel/my-package

Según parece, cada paquete de laravel tiene la terminación del comando de
instalación un poco diferente, por ejemplo:

Así se agrega e instala Laravel Breeze:

$ composer require laravel/breeze --dev

y así, se agrega e instala Laravel Collective:

$ composer require laravelcollective/html

La segunda forma de instalar paquetes es de manera manual, editando el paquete
composer.json.

Tal que:

En la sección require de composer.json agregar el paquete

"require": {
    "laravelcollective/html": "5.1.*"
}

y luego ejecutar update para que instale el paquete:

$ composer update

Agregar e instalar una version específica del paquete
=====================================================

$ composer require xxx/package:version

Ejemplo:

$ composer require laravelcollective/html:5.8

====================
Desinstalar paquetes
====================

Para desinstalar un paquete simplemente ejecuta el comando, este comando admite
las mismas opciones del comando composer require.

$ composer remove my-package

===================
Actualizar paquetes
===================

Podemos hacerlo de la siguiente forma:

Puedes actualizar todos los paquetes que se encuentran en composer.json

$ composer update

-----

Puedes actualizar únicamente uno o varios paquetes separándolos por espacios

$ composer update doctrine/dbal laravel/framework

----

$ Puedes actualizar todos los paquetes de un proveedor (‘vendor’) usando un
asterisco

$ composer update doctrine/*

===============
Rutas o Routing
===============

Las rutas son las encargadas de llamar a una acción que puede estar en un
controlador, redirigirnos a otra página web o podría ejecutar una función.

Las rutas de Laravel más básicas aceptan un URI y un Closure, proporcionando un
método muy simple y expresivo para definir rutas:

Route::get('foo', function () {
    return 'Hello World';
});

Los archivos de ruta predeterminados
====================================

Todas las rutas de Laravel se definen en el directorio /routes. Estos archivos
son cargados automáticamente por el framework. El archivo routes/web.php define
las rutas que son para su interfaz web. A estas rutas se les asigna el grupo de
middleware web, que proporciona características como el estado de la sesión y la
protección CSRF. Las rutas en las routes/api.php no tienen estado y se les
asigna el grupo de middleware api.

Para la mayoría de las aplicaciones, comenzará por definir rutas en su archivo
routes/web.php. Se puede acceder a las rutas definidas en routes/web.php
ingresando la URL de la ruta definida en su navegador.

Por ejemplo, puede acceder a la siguiente ruta navegando a
http://your-app.test/user en su navegador. La ruta sería:

Route::get('/user', 'UserController@index');

Métodos disponibles para las rutas
==================================

Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

A veces, es posible que deba registrar una ruta que responda a varios métodos
HTTP. Puede hacerlo utilizando el método match. O incluso puede registrar una
ruta que responda a todos los métodos HTTP utilizando el método any:

Route::match(['get', 'post'], '/', function () {
    //
});

Route::any('/', function () {
    //
});

Protección CSRF
===============

Recuerde, cualquier formulario HTML que apunte a rutas POST, PUT, PATCH o
DELETE que estén definidas en el archivo de rutas web debe incluir un campo de
token CSRF. De lo contrario, la solicitud será rechazada.

<form method="POST" action="/profile">
    @csrf
    ...
</form>

Redirigir rutas
===============

Si está definiendo una ruta que redirige a otro URI, puede usar el método
Route::redirect. Este método proporciona un atajo conveniente para que no tenga
que definir una ruta completa o un controlador para realizar una redirección
simple:

Route::redirect('/here', '/there');

Rutas de vista o View Routes
============================

Si su ruta solo necesita devolver una vista, puede usar el método Route::view.

Al igual que el método de redireccionamiento, este método proporciona un acceso
directo simple para que no tenga que definir una ruta completa o un controlador.

El método de vista acepta un URI como primer argumento y un nombre de vista como
segundo argumento. Además, puede proporcionar una matriz de datos para pasar a
la vista como un tercer argumento opcional:

Route::view('/welcome', 'welcome');

Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

Parametros de las rutas
=======================

A veces, necesitará capturar segmentos del URI dentro de su ruta. Por ejemplo,
es posible que deba capturar la identificación de un usuario de la URL.
Puede hacerlo definiendo parámetros de ruta:

Route::get('user/{id}', function ($id) {
    return 'User '.$id;
});

Puede definir tantos parámetros de ruta como requiera su ruta:

Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
});

Los parámetros de ruta siempre están encerrados entre llaves {} y deben constar
de caracteres alfabéticos y no pueden contener un carácter -.

En lugar de utilizar el carácter -, utilice un guión bajo (_). Los parámetros de
ruta se inyectan en callbacks/controladores de ruta según su orden; los
nombres de los argumentos de callbacks / controlador no importan.

Parámetros opcionales
=====================

Ocasionalmente, es posible que deba especificar un parámetro de ruta, pero haga
que la presencia de ese parámetro de ruta sea opcional. Puede hacerlo colocando
un ? marcador después del nombre del parámetro. Asegúrese de darle a la variable
correspondiente de la ruta un valor predeterminado:

Route::get('user/{name?}', function ($name = null) {
    return $name;
});

Route::get('user/{name?}', function ($name = 'John') {
    return $name;
});

Restricciones de expresiones regulares
======================================

Puede restringir el formato de los parámetros de su ruta utilizando el método
where en una instancia de ruta. El método where acepta el nombre del parámetro
y una expresión regular que define cómo se debe restringir el parámetro:

Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');

Route::get('user/{id}', function ($id) {
    //
})->where('id', '[0-9]+');

Route::get('user/{id}/{name}', function ($id, $name) {
    //
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

Restricciones globales
======================

Si desea que un parámetro de ruta esté siempre limitado por una expresión
regular determinada, puede usar el método de patrón.  Debe definir estos
patrones en el método de arranque de su RouteServiceProvider:

/**
 * Define your route model bindings, pattern filters, etc.
 *
 * @return void
 */
public function boot()
{
    Route::pattern('id', '[0-9]+');

    parent::boot();
}

Una vez que se ha definido el patrón, se aplica automáticamente a todas las
rutas usando ese nombre de parámetro:

Route::get('user/{id}', function ($id) {
    // Only executed if {id} is numeric...
});

Rutas nombradas
===============

Las rutas con nombre permiten la generación conveniente de URL o
redireccionamientos para rutas específicas. Puede especificar un nombre para una
ruta encadenando el método de nombre en la definición de ruta:

Route::get('user/profile', function () {
    //
})->name('profile');

También puede especificar nombres de ruta para las acciones del controlador:

Route::get('user/profile', 'UserProfileController@show')->name('profile');

ó

Route::post('','StudentController@store')->name('students.store');

Generación de URL para rutas con nombre
=======================================

Una vez que haya asignado un nombre a una ruta determinada, puede usar el
nombre de la ruta al generar URL o redireccionamientos a través de la
función de ruta global:

// Generating URLs...
$url = route('profile');

// Generating Redirects...
return redirect()->route('profile');

Si la ruta nombrada define parámetros, puede pasar los parámetros como segundo
argumento a la función de ruta. Los parámetros dados se insertarán
automáticamente en la URL en sus posiciones correctas:

Route::get('user/{id}/profile', function ($id) {
    //
})->name('profile');

$url = route('profile', ['id' => 1]);

Grupos de rutas
===============

Los grupos de rutas le permiten compartir atributos de ruta, como middleware o
espacios de nombres, en una gran cantidad de rutas sin necesidad de definir esos
atributos en cada ruta individual. Los atributos compartidos se especifican en
un formato de matriz como primer parámetro del método Route::group.

Los grupos anidados intentan "fusionar" atributos de forma inteligente con su
grupo principal. Middleware y where condiciones se combinan mientras se agregan
nombres, espacios de nombres y prefijos. Los delimitadores de espacio de nombres
y las barras inclinadas en los prefijos de URI se agregan automáticamente cuando
corresponde.

Middleware
==========

Para asignar middleware a todas las rutas dentro de un grupo, puede utilizar el
método de middleware antes de definir el grupo. El middleware se ejecuta en el
orden en el que se enumeran en la matriz:

Route::middleware(['first', 'second'])->group(function () {
    Route::get('/', function () {
        // Uses first & second Middleware
    });

    Route::get('user/profile', function () {
        // Uses first & second Middleware
    });
});

Namespaces
==========

Otro caso de uso común para los grupos de rutas es asignar el mismo namespace
a un grupo de controladores usando el método del espacio de nombres:

Route::namespace('Admin')->group(function () {
    // Controllers Within The "App\Http\Controllers\Admin" Namespace
});

Recuerde, de forma predeterminada, RouteServiceProvider incluye sus archivos de
ruta dentro un grupo de namespace, lo que le permite registrar rutas de
controlador sin especificar el prefijo completo del namespace
App\Http\Controllers. Por lo tanto, solo necesita especificar la parte del
namespace que viene después del namespace base App\Http\Controllers.

Rutas de sub dominios
=====================

Los grupos de rutas también se pueden usar para manejar el enrutamiento de
subdominios. A los subdominios se les pueden asignar parámetros de ruta al igual
que los URI de ruta, lo que le permite capturar una parte del subdominio para
usar en su ruta o controlador. El subdominio se puede especificar llamando al
método de dominio antes de definir el grupo:

Route::domain('{account}.myapp.com')->group(function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});

Prefijos de rutas
=================

El método de prefijo puede usarse para prefijar cada ruta en el grupo con un URI
dado. Por ejemplo, es posible que desee prefijar todos los URI de ruta dentro
del grupo con admin:

Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

Prefijos de nombre de ruta
==========================

El método del nombre se puede utilizar para prefijar cada nombre de ruta en el
grupo con una cadena determinada. Por ejemplo, es posible que desee agregar el
prefijo admin a todos los nombres de las rutas agrupadas. La cadena dada tiene
el prefijo del nombre de la ruta exactamente como se especifica, por lo que nos
aseguraremos de proporcionar el final . carácter en el prefijo:

Route::name('admin.')->group(function () {
    Route::get('users', function () {
        // Route assigned name "admin.users"...
    })->name('users');
});

Enlace de modelo de ruta
========================

Al inyectar un ID de modelo a una ruta o acción de controlador, a menudo
consultará para recuperar el modelo que corresponde a ese ID. El enlace del
modelo de ruta de Laravel proporciona una forma conveniente de inyectar
automáticamente las instancias del modelo directamente en sus rutas. Por
ejemplo, en lugar de inyectar la ID de un usuario, puede inyectar toda la
instancia del modelo de usuario que coincida con la ID dada.

Enlace implícito
================

Laravel resuelve automáticamente los modelos Eloquent definidos en rutas o
acciones de controlador cuyos nombres de variables con sugerencias de tipo
coinciden con el nombre de un segmento de ruta. Por ejemplo:

Route::get('api/users/{user}', function (App\User $user) {
    return $user->email;
});

Dado que la variable $ user está insinuada como el modelo App\User Eloquent y el
nombre de la variable coincide con el segmento de URI de {usuario}, Laravel
inyectará automáticamente la instancia del modelo que tiene una ID que coincide
con el valor correspondiente del URI de solicitud. Si no se encuentra una
instancia de modelo coincidente en la base de datos, se generará automáticamente
una respuesta HTTP 404.

Fallback Routes o Rutas de respaldo
===================================

Con el método Route::fallback, puede definir una ruta que se ejecutará cuando
ninguna otra ruta coincida con la solicitud entrante. Normalmente, las
solicitudes no gestionadas generarán automáticamente una página "404" a través
del controlador de excepciones de su aplicación. Sin embargo, dado que puede
definir la ruta alternativa dentro de su archivo routes/web.php, todo el
middleware del grupo de middleware web se aplicará a la ruta. Puede agregar
middleware adicional a esta ruta según sea necesario:

Route::fallback(function () {
    //
});

Limitación de tasa
==================

Laravel incluye un middleware para limitar el acceso a las rutas dentro de su
aplicación. Para comenzar, asigne el middleware del throttle a una ruta o grupo
de rutas. El middleware throttle acepta dos parámetros que determinan la
cantidad máxima de solicitudes que se pueden realizar en una cantidad
determinada de minutos. Por ejemplo, especifiquemos que un usuario autenticado
puede acceder al siguiente grupo de rutas 60 veces por minuto:

Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});

Método de formulario suplantación
=================================

Los formularios HTML no admiten acciones PUT, PATCH o DELETE. Por lo tanto, al
definir rutas PUT, PATCH o DELETE a las que se llama desde un formulario HTML,
deberá agregar un campo _method oculto al formulario. El valor enviado con el
campo _method se utilizará como método de solicitud HTTP:

<form action="/foo/bar" method="POST">
    <input type="hidden" name="_method" value="PUT">
    <input type="hidden" name="_token" value="{{ csrf_token() }}">
</form>

Puede usar la directiva @method Blade para generar la entrada _method:

<form action="/foo/bar" method="POST">
    @method('PUT')
    @csrf
</form>

Verbos HTTP
===========

Estos verbos realizan las siguientes acciones:

GET: recupera recursos.

POST: crea un recurso.

PUT/PATCH: modifica un recurso.

DELETE: elimina un recurso.

Partial Resource Routes

Rutas de recursos o resource Routes
===================================

Al declarar una ruta de recursos, puede especificar un subconjunto de acciones
que el controlador debe manejar en lugar del conjunto completo de acciones
predeterminadas:

Route::resource('photos', PhotoController::class)->only([
    'index', 'show'
]);

Route::resource('photos', PhotoController::class)->except([
    'create', 'store', 'update', 'destroy'
]);

Rutas de recursos de API
========================

Al declarar rutas de recursos que serán consumidas por las API, normalmente
querrá excluir rutas que presenten plantillas HTML como crear y editar. Por
conveniencia, puede utilizar el método apiResource para excluir automáticamente
estas dos rutas:

Route::apiResource('photos', PhotoController::class);

===========================================
Agregar una nueva ruta para mostrar mensaje
===========================================

En mysite/router/web.php agregamos lo siguiente:

Route::get('/hola', function () {
    echo "Hola!!!";
});

ó

Route::get('/greeting', function () {
    return 'Hello!!!';
});

Ahora visitamos http://127.0.0.1:8000/hola y veremos "Hola!!!".

Otro ejemplo:

En este ejmplo le vamos a pasar el valor desde la url al parámetro de la función
que lo está esperando, osea "name".

Route::get('articles/{name}', function ($name) {
    echo "El nombre que has colocado es: ".$name;
});

Si visitamos:

http://127.0.0.1:8000/articles/carlos

En el navegador veríamos:

El nombre que has colocado es: carlos

Ejemplo de una ruta con parámetro opcional
==========================================

Agregamos un ? luego de {name y en el parámetro de la función también podemos
colocar una cadena por defecto que se mostrará si no se coloca parámetro en la
url.

Route::get('articles/{name?}', function ($name = "No colocó nombre") {
    echo "El nombre que has colocado es: ".$name;
});

Si visitamos http://127.0.0.1:8000/articles/ veremos:

El nombre que has colocado es: No colocó nombre

Ejemplo de un prefijo para unas rutas
=====================================

Tenemos la ruta "articles" y dentro contiene un grupo de rutas:

Route::prefix('articles')->group(function () {
    /*Route::get('view/{article?}', function ($article = "Vacío" ) {
        echo $article;
    });*/
    Route::get('view', function () {
        echo "view";
    });
    Route::get('view2', function () {
        echo "view2";
    });
});

Accecibles desde http://127.0.0.1:8000/articles/view y
http://127.0.0.1:8000/articles/view2

Otro ejemplo pero recibiendo parámetro:

Route::prefix('articles')->group(function () {
    Route::get('view/{article?}', function ($article = "Vacío" ) {
        echo $article;
    });
});

Si vicitamos http://127.0.0.1:8000/articles/view/casa veremos:

casa

==============
Vistas o views
==============

Las vistas contienen el HTML proporcionado por su aplicación y separan la lógica
de su controlador/aplicación de su lógica de presentación. Las vistas se
almacenan en el directorio resources/views.

Una vista simple podría verse así:

<!-- View stored in resources/views/greeting.blade.php -->

<html>
    <body>
        <h1>Hello</h1>
    </body>
</html>

====================================
Crear una ruta y una vista sencillas
====================================

Crear una ruta
==============

En mysite/router/web.php agregamos lo siguiente:

Route::get('/hola', function () {
    return view('HolaMundo');
});

Como puede ver, el primer argumento pasado al asistente de vista corresponde al
nombre del archivo de vista en el directorio resources/views.

Crear una vista
===============

En mysite/resources/views/ creamos HolaMundo.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <p>Hola!!!</p>
    </body>
</html>

Ahora visitamos http://127.0.0.1:8000/hola y veremos "Hola!!!".

-----

Las vistas también pueden estar anidadas dentro de los subdirectorios del
directorio resources/views. La notación de "puntos" se puede utilizar para hacer
referencia a vistas anidadas. Por ejemplo, si su vista está almacenada en
resources/views/admin/profile.blade.php, puede hacer referencia a ella así:

Route::get('/admin', function () {
    return view('admin.profile');
});

ó

Route::get('/admin', function () {
    return view('admin.profile',[]);
});

Pasar datos a las vistas
========================

Se pueden pasar datos a la vista guardandolos en un arreglo en las rutas:

-----

web.php

Route::get('/', function () {
    return view('greeting', ['name' => 'James']);
});

Como puede ver, el primer argumento pasado al helper de la vista corresponde al
nombre del archivo de vista en el directorio resources/views. El segundo
argumento es una matriz de datos que deben estar disponibles para la vista. En
este caso, estamos pasando la variable de nombre, que se muestra en la vista
utilizando la sintaxis Blade.

-----

greeting.blade.php

<!DOCTYPE html>
<html lang="">
    <head>
        <meta charset="utf-8">
        <title>Laravel</title>
    </head>
    <body>
        <h1>Hello, {{ $name }}</h1>
    </body>
</html>

-----

Otro ejemplo:

return view('greetings', ['name' => 'Victoria']);

Al pasar información de esta manera, los datos deben ser una matriz con pares
clave/valor. Dentro de su vista, puede acceder a cada valor usando su clave
correspondiente, como <?php echo $key; ?>. Como alternativa a pasar una matriz
completa de datos a la función helper de la vista, puede usar el método with
para agregar datos individuales a la vista:

return view('greeting')->with('name', 'Victoria');

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <h1>Hello, {{ $name }}</h1>
        <br />
        <?php echo $name; ?>
    </body>
</html>

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

=============
Controladores
=============

Crear un controlador desde la línea de comandos
===============================================

Existe varias formas de crear tu controlador, una es creándolo manualmente y
otra desde la línea de comando, personalmente prefiero este último método, es
cuestión de gustos. El comando a utilizar será la siguiente:

$ php artisan make:controller HolaMundo

Para verificar que se creó correctamente podemos ir a la ruta de nuestro
proyecto: /app/Http/Controllers/HolaMundo.php, observando el siguiente código:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class HolaMundo extends Controller
{
    //
}

====================================================
Crear una ruta, un controlador y una vista sencillas
====================================================

Funciona hasta Laravel 7, con el 8 no funciona de esta manera a menos que se
especifique la ruta donde está el controlador.

1) En mysite/routes/web.php agregamos:

Route::get('/miruta','MiController@miFuncion');

Para Laravel 8:
Route::get('/miruta','App\Http\Controllers\MiController@miFuncion');

ó

use App\Http\Controllers\MiController;

Route::get('/miruta',[MiController::class, 'miFuncion']);

2) Creamos MiController.php en mysite7/app/Http/Controllers/ y debe contener lo
siquiente:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class MiController extends Controller
{
    public function miFuncion() {
        return view('mivista');
    }
}

3) Creamos mivista.blade.php en mysite7/resources/views/mivista.blade.php con el
siguiente contenido:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Laravel</title>
    </head>
    <body>
        <p>zzzz</p>
    </body>
</html>

4) Visitamos http://127.0.0.1:8000/miruta y deberíamos poder ver la vista
creada.

=======
Fuentes
=======

-http://blogger1889.blogspot.com/2017/07/hola-mundo-con-laravel.html

============================================================================
Crear una ruta que reciba parámetro y un controlador que reciba el parámetro
y muestre por pantalla el valor recibido.
============================================================================

web.php

use App\Http\Controllers\MyController;

Route::get('myroute/{id}',[MyController::class, 'myFuncition']);

-----

MyController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class MyController extends Controller
{
    public function myFuncition($id) {
        dd($id);
    }
}

-----

Si visitamos http://127.0.0.1:8000/myroute/1 debemos ver:

"1"

============
Función dd()
============

Es como un var dump, es un helper de Laravel.

Podemos usar dd() cuando necesitemos que el sistema nos devuelva algo para
probar:

dd("Mensajes de prueba");

===============================================
Consultar la base de datos desde un controlador
===============================================

web.php

use App\Http\Controllers\TestController;

Route::get('view/{id}',[TestController::class, 'view']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;

class TestController extends Controller
{
    public function view($id) {
        $article = Article::find($id);
        dd($article);
    }
}

Si vamos al navegador y visitamos http://127.0.0.1:8000/view/1 veremos algo
como:

App\Article {#213 ▼
  #table: "articles"
  #fillable: array:4 [▶]
  #connection: "pgsql"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #attributes: array:7 [▶]
  #original: array:7 [▶]
  #changes: []
  #casts: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: []
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #guarded: array:1 [▶]
}

Esto es porque ya tenemos una tabla Article que tiene guardados datos en la base
de datos.

====================================================================
Consutlar los datos relacionados a un artículo, desde el controlador
====================================================================

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;

class TestController extends Controller
{
    public function view($id) {
        $article = Article::find($id);
        $article->category;
        $article->user;
        $article->tag;
        dd($article);
    }
}

Si visitamos http://127.0.0.1:8000/view/1 veremos:

App\Article {#213 ▼
  #table: "articles"
  #fillable: array:4 [▶]
  #connection: "pgsql"
  #primaryKey: "id"
  #keyType: "int"
  +incrementing: true
  #with: []
  #withCount: []
  #perPage: 15
  +exists: true
  +wasRecentlyCreated: false
  #attributes: array:7 [▶]
  #original: array:7 [▶]
  #changes: []
  #casts: []
  #dates: []
  #dateFormat: null
  #appends: []
  #dispatchesEvents: []
  #observables: []
  #relations: array:2 [▶]
  #touches: []
  +timestamps: true
  #hidden: []
  #visible: []
  #guarded: array:1 [▶]
}

Donde "#relations: array:2 [▶]" se despliega al darle click:

#relations: array:2 [▼
  "category" => App\Category {#214 ▶}
  "user" => App\User {#889 ▶}
]

y estos 2 ítems a su vez se pueden desplegar para ver los demás datos asociados.

==========================================================
Crear un registro en la base de datos desde un controlador
==========================================================

En este ejemplo vamos a crear un usuario en la base de datos.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('create',[TestController::class, 'create']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Article;
use App\User;

class TestController extends Controller
{
    public function create() {
        $user = new User;
        $user->name='Argenis';
        $user->email='aosorio@mail.com';
        $user->password=bcrypt('123456');
        $user->save();
    }
}

Al visitar http://127.0.0.1:8000/create/ nos debe crear el registro en la base
de datos.

===============================================================
Actualizar un registro en la base de datos desde un controlador
===============================================================

En este ejemplo vamos a actualizar el email de un usuario registrado en la base
de datos cuyo id sea 1.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('update',[TestController::class, 'update']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function update() {
        $user = User::find(1);
        $user->email='another@mail.com';
        $user->save();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/update/ nos debe actualizar el email del
registro con id igual a 1 en la base de datos.

===============================================================================
Actualizar un registro en la base de datos desde un controlador pasandole el id
===============================================================================

En este ejemplo vamos a actualizar el email de un usuario registrado en la base
pasando el id desde la url.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('update/{id}',[TestController::class, 'update']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function update($id) {
        $user = User::find($id);
        $user->email='xxx@mail.com';
        $user->save();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/update/1 nos debe actualizar el el email del
registro en la base de datos que tenga el id igual a 1.

=============================================================
Eliminar un registro en la base de datos desde un controlador
=============================================================

En este ejemplo vamos a eliminar un usuario registrado en la base de datos cuyo
id sea 1.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('delete',[TestController::class, 'delete']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function delete() {
        $user = User::find(4);
        $user->delete();
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/delete/ nos debe eliminar el registro en la
base de datos con el id igual a 4.

=============================================================================
Eliminar un registro en la base de datos desde un controlador pasándole el id
por la url como parámetro
=============================================================================

En este ejemplo vamos a eliminar un usuario registrado en la base de datos cuyo
id sera el que le pasemos por la url como parámetro.

-----

Routes.php

<?php

use App\Http\Controllers\TestController;

Route::get('delete/{id}',[TestController::class, 'delete']);

-----

TestController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\User;

class TestController extends Controller
{
    public function delete($id) {
        $user = User::find($id);
        $user->delete();
        //User::destroy($id);
        dd($user);
    }
}

Al visitar http://127.0.0.1:8000/delete/1 nos debe eliminar el registro en la
base de datos que tenga el id igual a 1.

También podriamos destruir el registro directamente con el modelo si tenemos su
ID:

User::destroy($id);

===============================================
Pasar valores a las vistas desde el controlador
===============================================

Route::get('article',[TestController::class, 'article']);

-----

class TestController extends Controller
{
    public function article() {
        $article = "Some content";
        return view('article', ['data'=>$article]);
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <?php echo $data; ?>
    </body>
</html>

Si visitamos

http://127.0.0.1:8000/article veremos:

"Some content"

================================================================
Pasar valores a las vista desde el controlador mediante un query
================================================================

Route::get('article/{id}',[TestController::class, 'article']);

-----

class TestController extends Controller
{
    public function article($id) {
        $article = Article::find($id);
        return view('article', ['data'=>$article]);
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <!-- Se pueden consultar los datos así -->
        <?php echo $data; ?>
        <br />
        <!-- O acceder a los datos del arreglo article -->
        <?php echo $data->title; ?>
    </body>
</html>

Si visitamos http://127.0.0.1:8000/article/1 veremos, siempre y cuando haya
datos en la base de datos:

Article
{"id":1,"title":"Noticia de \u00faltima hora","content":"Contenido de la noticia","user_id":1,"category_id":1,"created_at":"2021-05-06 03:25:24","updated_at":"2021-05-06 03:25:24"}
Noticia de última hora

===================================================
Rutas, Controladores y Vistas para un CRUD sencillo
===================================================

List de CRUD
============

Listar todos los registros guardaros:

Vamos a crear en nuestro archivo de rutas un grupo de rutas asociadas a cada uno
de los metodos (index, create, store, show, edit, update, delete), esto se hace
con una ruta de tipo Resource o recurso, modificando el archivo routes agregando
el siguiente codigo:

Route::resource('students', 'StudentController');

-----

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }
}

-----

resources/views/students/index.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>Students</p>
    @foreach ($students as $student)
      <p>
        -First name: {{ $student->first_name }}
        <br />
        -Last name: {{ $student->last_name }}
        <br />
        -Identification number: {{ $student->identification_number }}
      </p>
    @endforeach
  </body>
</html>

También podemos agregar una tabla html:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>List of students</p>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

Create del CRUD
===============

Método store - Funcion de almacenamiento
========================================

Este metodo es donde despues de haber entrado a create se reciben los datos y se
guardan en la base de datos, para poder recibir la informacion en este ejemplo
vamos a usar la clase Request que significa peticion y es una clase que Laravel
agrega por nosotros cuando creamos el controlador, vamos a pasar por parametro
la peticion en el metodo definiendo que es una variable de la clase Request y
despues de eso podemos recuperar por el nombre del campo del formulario(atributo
name) la informacion enviada, entonces el metodo quedaria de la siguiente forma:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index');
    }
}

-----

app/Http/Requests/Request.php

<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

abstract class Request extends FormRequest
{
    //
}

-----

resources/views/students/create.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create</title>
  </head>
  <body>
    <p>Create student</p>
    {!! Form::open([ 'route' => 'students.store', 'method' => 'POST']) !!}
      <div class="form-group">
        {!! Form::label('first_name', 'First name') !!}
        {!! Form::text('first_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('last_name', 'Last name') !!}
        {!! Form::text('last_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('identification_number', 'Identification number') !!}
        {!! Form::text('identification_number', null) !!}
      </div>

      <div class="form-group">
        {!! Form::submit('Save') !!}
      </div>
    {!! Form::close() !!}
  </body>
</html>

Para poder acceder a a create agregamos en la vista de index el siguiente enlace

<a href="{{ route('students.create') }}">NEW</a>

tal que:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    <p>List of students</p>
    <a href="{{ route('students.create') }}">NEW</a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

create.blade.php también puede contener un formulario normal sin hacer uso de
Laravel Collective

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Create student</title>
  </head>
  <body>
    <h1>Create student</h1>
    <form action="{{ route('students.store') }}" method="POST">@csrf
      <div>
        <label>First name</label>
        <input type="text" name="first_name">
      </div>
      <div>
        <label>Last name</label>
        <input type="text" name="last_name">
      </div>
      <div>
        <label>Identification number</label>
        <input type="text" name="identification_number">
      </div>
      <button type="submit" >SAVE</button>
    </form>
  </body>
</html>

Update de CRUD
==============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index');
    }
}

-----

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Update</title>
  </head>
  <body>
    <p>Update student</p>
    {!! Form::model($student, ['route' => ['students.update', $student], 'method' => 'PUT']) !!}
      <div class="form-group">
        {!! Form::label('first_name', 'First name') !!}
        {!! Form::text('first_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('last_name', 'Last name') !!}
        {!! Form::text('last_name', null) !!}
      </div>

      <div class="form-group">
        {!! Form::label('identification_number', 'Identification number') !!}
        {!! Form::text('identification_number', null) !!}
      </div>

      <div class="form-group">
        {!! Form::submit('Save') !!}
      </div>
    {!! Form::close() !!}
  </body>
</html>

===================================================
Filtrar los datos de una consulta en el controlador
===================================================

En este ejmplo vamos a ordenar los reqistros por el ID pero de manera
descendente y también solo vamos a mostrar 3 registros.

public function index()
{
    $users = User::orderBy('id', 'ASC')->paginate(3);
    //$users = User::orderBy('id', 'DESC')->paginate(3);
    return view('users.index')->with('users', $users);
}

Mensaje cuando se guarda un formulario
======================================

Por ejemplo en el caso del formulario create y edit, cuando guardemos, podemos
enviar un mensaje a la vista con:

->with('info','Student was created!');

->with('info','Student data was updated');

Tal que:

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }
}

Y agregamos en index que es la que va a recibir el mensaje lo sigueinte:

@if(Session::has('info'))
  {{ Session::get('info') }}
@endif

Tal que:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    @if(Session::has('info'))
      Message: {{ Session::get('info') }}
    @endif
    <p>List of students</p>
    <a href="{{ route('students.create') }}">NEW</a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
          <a href="{{ route('students.edit', $student->id) }}">UPDATE</a>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

Show del CRUD
=============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }

    /*
    |--------------------------------------------------------------------------
    | SHOW
    |--------------------------------------------------------------------------
    */
    public function show($id)
    {
        $student = Student::find($id);
        return view('students.show', compact('student'));
    }
}

-----

show.blade.php

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Show</title>
  </head>
  <body>
    <p>Show student</p>
    <p>
      First name: {{ $student->first_name }}
    </p>
    <p>
      Last name: {{ $student->last_name }}
    </p>
    <p>
      Identification number: {{ $student->identification_number }}
    </p>
  </body>
</html>

Delete del CRUD
===============

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Student;
//use App\Http\Requests\StudentRequest;

class StudentController extends Controller
{
    /*
    |--------------------------------------------------------------------------
    | LIST
    |--------------------------------------------------------------------------
    */
    public function index()
    {
        $students = Student::get();
        return view('students.index')->with('students', $students);
    }

    /*
    |--------------------------------------------------------------------------
    | CREATE
    |--------------------------------------------------------------------------
    */
    public function create()
    {
        return view('students.create');
    }

    public function store(Request $request)
    {
        $student = new Student($request->all());
        $student->save();
        return redirect()->route('students.index')->with('info','Student was created!');
    }

    /*
    |--------------------------------------------------------------------------
    | UPDATE
    |--------------------------------------------------------------------------
    */
    public function edit($id)
    {
        $student = Student::find($id);
        return view('students.edit')->with('student',$student);
    }

    public function update(Request $request, $id)
    {
        $student = Student::find($id);
        $student->first_name = $request->input('first_name');
        $student->last_name = $request->input('last_name');
        $student->identification_number = $request->input('identification_number');
        $student->save();
        return redirect()->route('students.index')->with('info','Student data was updated!');
    }

    /*
    |--------------------------------------------------------------------------
    | SHOW
    |--------------------------------------------------------------------------
    */
    public function show($id)
    {
        $student = Student::find($id);
        return view('students.show', compact('student'));
    }

    /*
    |--------------------------------------------------------------------------
    | DELETE
    |--------------------------------------------------------------------------
    */
    public function destroy($id)
    {
        $student = Student::find($id);
        $student->delete();
        return redirect()->route('students.index')->with('info','Student data was deleted!');
    }
}

-----

Agregado formualario para eliminar desde la columna actions

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Students</title>
  </head>
  <body>
    @if(Session::has('info'))
      Message: {{ Session::get('info') }}
    @endif
    <p>List of students</p>
    <a href="{{ route('students.create') }}">
      <button>NEW</button>
    </a>
    <table border="1px" cellspacing="0px" style="width:100%;">
      <thead>
        <tr>
          <th class="text-center">ID</th>
          <th class="text-center">First name</th>
          <th class="text-center">Last name</th>
          <th class="text-center">Identification number</th>
          <th class="text-center">Actions</th>
        </tr>
      </thead>
      <tbody>
      @foreach ($students as $student)
      <tr>
        <td class="text-center">{{ $student->id }}</td>
        <td class="text-center">{{ $student->first_name }}</td>
        <td class="text-center">{{ $student->last_name }}</td>
        <td class="text-center">{{ $student->identification_number }}</td>
        <td>
          <a href="{{ route('students.edit', $student->id) }}">
            <button>UPDATE</button>
          </a>
          <a href="{{ route('students.show', $student->id) }}">
            <button>SHOW</button>
          </a>
          <form action="{{ route('users.destroy', $user->id) }}" method="POST">
            @csrf
            @method('DELETE')
            <button type="submit" onclick="return confirm('Are you sure you want to delete the record? ');">DELETE</button>
          </form>
        </td>
      </tr>
      @endforeach
      </tbody>
    </table>
  </body>
</html>

===========================
CRUD de usuarios de Laravel
===========================

1) Creamos una ruta de recursos:

Route::resource('users','UserController');

2) Creamos un controlador:

$ php artisan make:controller UserController

3) Editar el controlador creado y agregar las funciones index, create, store,
edit, update, show, destroy correspondientes.

4) Crear las vistas correspondientes a cada función del controlador.

=====
Blade
=====

Blade es el motor de plantillas simple pero poderoso provisto con Laravel. A
diferencia de otros motores de plantillas PHP populares, Blade no le impide usar
código PHP simple en sus vistas. De hecho, todas las vistas de Blade se compilan
en código PHP simple y se almacenan en caché hasta que se modifican, lo que
significa que Blade agrega esencialmente cero gastos generales a su aplicación.

Los archivos de vista Blade usan la extensión de archivo .blade.php y
generalmente se almacenan en el directorio de resources/views.

¿Qué es blade en laravel?
=========================

Blade es un motor de plantillas simple y a la vez poderoso proporcionado por
Laravel. A diferencia de otros motores de plantillas populares de PHP, Blade no
te impide utilizar código PHP plano en tus vistas.

Usando blade en la vista
========================

Ejemplo:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        <p>Article</p>
        <!-- Imprimiendo valores con blade -->
        {{ $article->title }}
    </body>
</html>

==================
Ciclo for en blade
==================

@for ($i=0; $i<=5; $i++)
  {{ $i }}
@endfor

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Article</title>
    </head>
    <body>
        @for ($i=0; $i<=5; $i++)
          {{ $i }}
        @endfor
    </body>
</html>

Nos imprime.

0 1 2 3 4 5

===========
if en blade
===========

@if (1 == 1)
  {{ "Es igual a 1" }}
@endif

=========================
if, elseif, else en blade
=========================

<?php $records=[1,2,3] ?>
@if (count($records) === 1)
    I have one record!
@elseif (count($records) > 1)
    I have multiple records!
@else
    I don't have any records!
@endif

Ejemplos prácticos:

@if ($student->id == 1)
  El ID del user es igual a 1
@endif

-----

@if ($student->id == 1)
    El ID del user es igual a 1
@elseif ($student->id == 2)
    El ID del user es igual a 2
@else
    El ID del user es diferente de 1 y de 2.
@endif

-----

@if ($student->id == 1)
    <button>1</button>
@elseif ($student->id == 2)
    <button>2</button>
@else
@endif

================
foreach en blade
================

<?php $numbers=[1,2,3,4,5] ?>

@foreach ($numbers as $number)
  {{ $number }}
@endforeach

Otro ejemplo:

Como tags es una arreglo, debemos recorrerlo:

Accedmos a los tags asociados a article y los mostramos.

@foreach ($article->tags as $tag)
  {{ $tag->name }}
@endforeach

-----

@foreach ($users as $user)
    <p>This is user {{ $user->id }}</p>
@endforeach

================
forelse en blade
================

@forelse ($users as $user)
    <li>{{ $user->name }}</li>
@empty
    <p>No users</p>
@endforelse

=====================
Comentarios en blade
=====================

Blade también le permite definir comentarios en sus vistas.  Sin embargo, a
diferencia de los comentarios HTML, los comentarios Blade no se incluyen en el
HTML devuelto por su aplicación:

{{-- This comment will not be present in the rendered HTML --}}

===============================
Herencia de plantilla con Blade
===============================

Dos de los principales beneficios de utilizar Blade son la herencia de
plantillas y las secciones. Para empezar, echemos un vistazo a un ejemplo
sencillo.

base.blade.php

<html>
  <head>
    <title>App Name - @yield('title')</title>
  </head>
  <body>
    @section('header')
      aaaaaaaaaaaa
    @show

    @section('content')
      11111111111
    @show

    @section('footer')
      11111111111
    @show
  </body>
</html>

Como puede ver, este archivo base contiene un marcado HTML típico. Sin embargo,
tome nota de las directiva @section. La directiva @section, como su nombre lo
indica, define una sección de contenido

Ahora que hemos definido un diseño base para nuestra aplicación, definamos una
página secundaria que herede el diseño.

Al definir una vista secundaria, utilice la directiva Blade @extends para
especificar qué diseño debe "heredar" la vista secundaria. Las vistas que
extienden un diseño Blade pueden inyectar contenido en las secciones del diseño
utilizando las directivas @section.

child.blade.php

@extends('base')

@section('title', 'xxxxxxxx')

@section('header')
  <p>header, header, header</p>
@endsection

@section('content')
  @parent
  <p>content, content, content</p>
@endsection

@section('footer')
  <p>footer, footer, footer</p>
@endsection

-----

Si se agrega en la vista child alguna sección, el contenido será mostrado en
detrimento de la sección master de la vista base.

En este ejemplo, la sección content utiliza la directiva @parent para agregar
(en lugar de sobrescribir) contenido a la seccion content. La directiva @parent
será reemplazada por el contenido del diseño cuando se renderice la vista.

===========================
Directivas de autenticación
===========================

Las directivas @auth y @guest pueden usarse para determinar rápidamente si el
usuario actual está autenticado o es un invitado:

@auth
    // The user is authenticated...
@endauth

@guest
    // The user is not authenticated...
@endguest

Si es necesario, puede especificar la protección de autenticación que se debe
verificar al usar las directivas @auth y @guest:

@auth('admin')
    // The user is authenticated...
@endauth

@guest('admin')
    // The user is not authenticated...
@endguest

Include en blade
================

Include sirve para incluir los contenidos de otras vistas dentro de una sección:

Ejemplo:

Creamos list.blade.php

<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

y la podemos incluir dentro del bloque content de la vista child:

@extends('base')

@section('title')
    Article
@endsection

@section('header')
    <h1>This is the child header secction</h1>
@endsection

@section('content')
    @include('list')
@endsection

@section('footer')
@endsection

Si revisamos la vista en el navegador veremos la lista incluída en el bloque
content.

Partials en blade
=================

Es una carpeta que se crea en las views donde se pueden almacenar secciones del
código que compone la plantilla, pero esta carpeta pueden ser diferentes
carpetas y las podemos llamar de muchas maneras.

La directiva @yield
===================

La directiva @yield se usa para mostrar el contenido de una sección determinada.

En otras palabras, los yields básicamente lo que hacen es crear secciones desde
nuestra plantilla, para luego rellenarlas desde la vista donde estén siendo
usadas.

En base:

<title>App Name - @yield('title')</title>

En child:

@section('title')
  Index
@endsection

ó

@section('title', 'Page Title')

La sección se llama title porque así le pusimos al yield.

Si visitamos a child con el navegador veremos en title

App Name - Page title

Otro ejemplo:

@yield se trae todas las propiedades de la etiqueta en que esté declarada
incluyendo la etiqueta misma

En base:

<h1 class="title">@yield('TitlePost')</h1>

En child:

@section('TitlePost')
Some text...
@endsection

Esto se traduce en el código fuente del child en el navegador en:

<h1 class="title">Some text...</h1>

-----

Pasando un segundo parámetro a yield, pondremos una cadena por defecto

Base:

<title>@yield('title', 'Default')</title>

Child:

@section('title', 'Index')

Se traduce en:

<title>Index</title>

Si se deja @section('title') mostrará:

<title>Default</title>

=========================================
Mostrar datos en la vista, otros ejemplos
=========================================

Siguiendo el ejemplo del blog, en article.blade.php tenemos:

<h1>{{ $article->title }}</h1>
<br />
<p>{{ $article->content }}</p>
<br />
Author: {{ $article->user->name }}
<br />
Category: {{ $article->category->name }}

De esta manera accedemos a los datos de la tabla articles y todos lode datos de
sus tablas asociadas.

Llamar un css a una plantilla blade
===================================

Los archivos CSS se pueden guardar en cualquier lugar pero Laravel por defecto
crea la carpeta CSS en public/css en icluso crea un app.css

Con solo incluír en la plantilla:

<link rel="stylesheet" type="text/css" href="/css/app.css">

ya tenemos acceso a esos estilos.

Aunque se recomienda usando ladirectiva asset:

<link rel="stylesheet" type="text/css" href="{{ asset('css/app.css') }}">

asset lo que hace es situarse en la carpeta public y navegar por las carpetas
que le indiquemos hasta conseguir el archivo definido, en este caso app.css.

==========
Campo CSRF
==========

Siempre que defina un formulario HTML en su aplicación, debe incluir un campo de
token CSRF oculto en el formulario para que el middleware de protección CSRF
pueda validar la solicitud. Puede usar la directiva @csrf Blade para generar el
campo de token:

<form method="POST" action="/profile">
    @csrf

    ...
</form>

============
Campo método
============

Dado que los formularios HTML no pueden realizar solicitudes PUT, PATCH o
DELETE, deberá agregar un campo _method oculto para falsificar estos verbos
HTTP.

La directiva @method Blade puede crear este campo por usted:

<form action="/foo/bar" method="POST">
    @method('PUT')

    ...
</form>

=================================
Integrar Bootstrap en un proyecto
=================================

Los archivos CSS se pueden guardar en cualquier lugar pero Laravel por defecto
crea la carpeta CSS en public/css en icluso crea un app.css

1) Descargar los archivos necesarios para usar Bootstrap (css, js, jquery).

2) Crer una carpeta bootstrap en my-app/public/

3) Pegar adentro las carpetas css y js de Bootstrap y también la de Jquery.

4) Crear una plantilla que será la plantilla base y llamar a bootstrap con
lo necesario, ejemplo:

<!-- Bootstrap core CSS-->
<link rel="stylesheet" type="text/css" href="{{ asset ('bootstrap/css/bootstrap.min.css') }}">

<!-- Bootstrap core JavaScript-->
<script src="{{ asset ('bootstrap/js/jquery/jquery-3.3.1.slim.min.js') }}" type="text/javascript"></script>
<script src="{{ asset ('bootstrap/js/popper.min.js') }}" type="text/javascript"></script>
<script src="{{ asset ('bootstrap/js/bootstrap.min.js') }}" type="text/javascript"></script>

asset lo que hace es situarse en la carpeta public y navegar por las carpetas
que le indiquemos hasta conseguir el archivo definido, en este caso app.css.

En Laravel 5.8.x
================

Bootstrap viene incluído en esta versión de Laravel, por lo que hay hay que
ejecutar la compilación de los paquetes de node con:

$ npm run dev

Esto generara una modificación de los archivos:

public/css/app.css
public/js/app.js

Por lo cual solo resta hacer el llamado de los archivos en la plantilla base,
ejemplo:

<!DOCTYPE html>
<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>@yield('title')</title>
    <!-- Bootstrap core CSS-->
    <link rel="stylesheet" type="text/css" href="{{ asset ('css/app.css') }}">
    <!-- Bootstrap core JavaScript-->
    <script src="{{ asset ('js/app.js') }}" type="text/javascript"></script>
  </head>
  <body>
    <script>
    $(document).ready(function(){
      alert("¡Hola esto es una alerta!");
    });
    </script>
    @section('content')
      Base content...
    @show
  </body>
</html>

===========================================================================
Consultar la versión de Laravel y de PHP directamente en una plantilla html
===========================================================================

Laravel v{{ Illuminate\Foundation\Application::VERSION }}
<br />
PHP v{{ PHP_VERSION }}

==============
Kits de inicio
==============

Para darle una ventaja en la construcción de su nueva aplicación Laravel, nos
complace ofrecer kits de inicio de aplicaciones y autenticación. Estos kits
configuran automáticamente su aplicación con las rutas, controladores y vistas
que necesita para registrar y autenticar a los usuarios de su aplicación.

Si bien puede utilizar estos kits de inicio, no son obligatorios.  Eres libre de
crear tu propia aplicación desde cero simplemente instalando una copia nueva de
Laravel.

Laravel Breeze
==============

Laravel Breeze es una implementación mínima y simple de todas las funciones de
autenticación de Laravel, que incluyen inicio de sesión, registro,
restablecimiento de contraseña, verificación de correo electrónico y
confirmación de contraseña. La capa de vista predeterminada de Laravel Breeze
está formada por plantillas Blade simples diseñadas con Tailwind CSS.  Breeze
proporciona un maravilloso punto de partida para comenzar una nueva aplicación
de Laravel.

Primero, debe crear una nueva aplicación Laravel, configurar su base de datos y
ejecutar sus migraciones de base de datos:

$ php artisan migrate

Una vez que haya creado una nueva aplicación Laravel, puede instalar Laravel
Breeze usando Composer:

$ composer require laravel/breeze --dev

Después de que Composer haya instalado el paquete Laravel Breeze, puede ejecutar
el comando de artisan $ breeze:install. Este comando publica las vistas de
autenticación, las rutas, los controladores y otros recursos de su aplicación.

Laravel Breeze publica todo su código en su aplicación para que tenga control
total y visibilidad sobre sus características e implementación. Después de
instalar Breeze, también debe compilar sus activos para que el archivo CSS de su
aplicación esté disponible:

$ php artisan breeze:install

$ npm install

$ npm run dev

$ php artisan migrate

A continuación, puede navegar a las URL /login o /register de su aplicación en
su navegador web. Todas las rutas de Breeze se definen en el archivo
routes/auth.php.

Breeze & Inertia
================

Laravel Breeze también ofrece una implementación de frontend Inertia.js
impulsada por Vue. Para usar la inercia stack, pase la opción --inertia al
ejecutar el comando breeze: install Artisan:

$ php artisan breeze:install --inertia

$ npm install

$ npm run dev

$ php artisan migrate

======================
Nombres para las rutas
======================

Las rutas con nombre permiten la generación conveniente de URL o
redireccionamientos para rutas específicas. Puede especificar un nombre para una
ruta encadenando el método de nombre en la definición de ruta:

Route::get('/user/profile', function () {
    //
})->name('profile');

También puede especificar nombres de ruta para las acciones del controlador:

Route::get(
    '/user/profile',
    [UserProfileController::class, 'show']
)->name('profile');

==========
Middleware
==========

El middleware proporciona un mecanismo conveniente para inspeccionar y filtrar
las solicitudes HTTP que ingresan a su aplicación.  Por ejemplo, Laravel incluye
un middleware que verifica que el usuario de su aplicación esté autenticado. Si
el usuario no está autenticado, el middleware redirigirá al usuario a la
pantalla de inicio de sesión de su aplicación.  Sin embargo, si el usuario está
autenticado, el middleware permitirá que la solicitud continúe en la aplicación.

Se puede escribir middleware adicional para realizar una variedad de tareas
además de la autenticación. Por ejemplo, un middleware de registro puede
registrar todas las solicitudes entrantes en su aplicación. Hay varios
middleware incluidos en el marco de Laravel, incluido el middleware para la
autenticación y la protección CSRF. Todos estos middleware se encuentran en el
directorio app/Http/Middleware.

===============================
Migraciones de la base de datos
===============================

Las migraciones son como un control de versiones para su base de datos, lo que
le permite a su equipo definir y compartir la definición del esquema de la base
de datos de la aplicación. Si alguna vez ha tenido que decirle a un compañero de
equipo que agregue manualmente una columna a su esquema de base de datos local
después de extraer sus cambios desde el control de fuente, se ha enfrentado al
problema que resuelven las migraciones de base de datos.

La fachada (facade) del esquema de Laravel proporciona soporte independiente de
la base de datos para crear y manipular tablas en todos los sistemas de base de
datos compatibles con Laravel. Normalmente, las migraciones utilizarán esta
fachada para crear y modificar tablas y columnas de bases de datos.

Generando migraciones
=====================

Puede utilizar el comando make:migration de artisan para generar una migración
de base de datos. La nueva migración se colocará en su directorio
database/migraciones. Cada nombre de archivo de migración contiene una marca de
tiempo que permite a Laravel determinar el orden de las migraciones:

$ php artisan make:migration create_flights_table

Laravel usará el nombre de la migración para intentar adivinar el nombre de la
tabla. Si Laravel puede determinar el nombre de la tabla a partir del nombre de
la migración, Laravel completará previamente el archivo de migración generado
con la tabla especificada. De lo contrario, simplemente puede especificar la
tabla en el archivo de migración anualmente.

Si desea especificar una ruta personalizada para la migración generada, puede
usar la opción --path al ejecutar el comando make:migration. La ruta dada debe
ser relativa a la ruta base de su aplicación.

Ejemplo
=======

Agregar el campo "type" a la tabla por defecto User de Laravel. Esta
modificación se realiza manualmente sobre el archivo User.php.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class CreateUsersTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->enum('type',['member','admin'])->default('member');
            $table->rememberToken();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
}

-----

Generar una nueva migración y crear una tabla llamada categories

$ php artisan make:migration add_categories_table --create=categories

Esto nos crea una estructura de migración básica, a la cual le agregamos el
campo "name" de tipo string y con un máximo de caracteres de 60, esta
modificación se realiza manualmente sobre el archivo.

Al crearla la migracion con --create=categories nos agrega campos por defecto en
la función up() y down() así como el método Schema.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddCategoriesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('categories', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name', 60);
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('categories');
    }
}

Al crearla la migracion sin --create=categories nos crea la estrucuta de la
función up() y down() vacías.

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddCategoriesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        //
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        //
    }
}

===========================
Estructura de una migración
===========================

Una clase de migración contiene dos métodos: up y down. El método up se usa para
agregar nuevas tablas, columnas o índices a su base de datos, mientras que el
método down debe revertir las operaciones realizadas por el método up.

=======================
Rolling Back Migrations
=======================

Para revertir la última operación de migración, puede utilizar el comando
rollback. Este comando revierte el último "lote" de migraciones, que puede
incluir varios archivos de migración:

$ php artisan migrate:rollback

Puede revertir un número limitado de migraciones proporcionando la opción al
comando de reversión.  Por ejemplo, el siguiente comando revertirá las últimas
cinco migraciones:

$ php artisan migrate:rollback --step=5

El comando migrate:reset revertirá todas las migraciones de su aplicación:

$ php artisan migrate:reset

==============================================
Restricciones de Foreign Key o lláves foráneas
==============================================

Laravel también proporciona soporte para crear restricciones de clave foránea,
que se utilizan para forzar la integridad referencial a nivel de la base de
datos. Por ejemplo, definamos una columna user_id en la tabla de publicaciones
que hace referencia a la columna id en una tabla de usuarios:

Schema::table('posts', function (Blueprint $table) {
    $table->unsignedBigInteger('user_id');

    $table->foreign('user_id')->references('id')->on('users');
});

También puede especificar la acción deseada para las propiedades "on delete" y
"on update" de la restricción:

$table->foreign('user_id')
      ->references('id')->on('users')
      ->onDelete('cascade');

Para eliminar una clave foránea, puede utilizar el método dropForeign. Las
restricciones de clave externa utilizan la misma convención de nomenclatura que
los índices. Entonces, concatenamos el nombre de la tabla y las columnas en la
restricción y luego agregaremos el sufijo "_foreign":

$table->dropForeign('posts_user_id_foreign');

O bien, puede pasar un valor de matriz que utilizará automáticamente el nombre
de restricción convencional al soltar:

$table->dropForeign(['user_id']);

Puede habilitar o deshabilitar las restricciones de clave externa dentro de sus
migraciones mediante los siguientes métodos:

Schema::enableForeignKeyConstraints();

Schema::disableForeignKeyConstraints();

Ejemplo de campo tipo integer para coumnas de tipo entero
=========================================================

$table->integer('votes');

Ejemplos de asignar relaciones entre tablas
===========================================

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddArticlesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('title');
            $table->text('content');
            /* Asignando las relaciones de los Artículos con las categorías y
            los usuarios */
            $table->unsignedInteger('user_id');
            $table->unsignedInteger('category_id');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('category_id')->references('id')->on('categories')->onDelete('cascade');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('articles');
    }
}

Ejemplo de relaciones Many to Many o muchos a muchos
====================================================

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddTagsTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('tags', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('name');
            $table->timestamps();
        });
        /* Ejemplo de una relación muchos a muchos Many To Many
        para Articles $ Tags */
        Schema::create('article_tag', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->unsignedInteger('article_id');
            $table->unsignedInteger('tag_id');
            $table->foreign('article_id')->references('id')->on('articles');
            $table->foreign('tag_id')->references('id')->on('tags');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('tags');
    }
}

Método softDeletes()
====================

El método softDeletes agrega una columna equivalente a nullable deleted_at
TIMESTAMP con una precisión opcional (dígitos totales). Esta columna está
destinada a almacenar la marca de tiempo deleted_at necesaria para la
funcionalidad de "eliminación suave" de Eloquent:

$table->softDeletes($column = 'deleted_at', $precision = 0);

===============
Crear un modelo
===============

El nombre de los modelos debe ír como el nombre de la tabla pero en singular,
si tengo una tabla Categories mi modelo se debe llamar Category.

$ php artisan make:model Category

Al crear un modelo, se crea el archivo Category.php en /app/Category.php

Campos $fillable
================

Son los campos permitidos para mostrar los objetos json y suelen ser los mismos
campos definidos en las migraciones:

Ejemplo de un modelo de Artículo que se relaciona con categorías:

**Migración**

<?php

use Illuminate\Support\Facades\Schema;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AddArticlesTable extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('articles', function (Blueprint $table) {
            $table->bigIncrements('id');
            $table->string('title');
            $table->text('content');
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('articles');
    }
}

**Modelo**

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];
}

Luego, se ejecutan las migraciones para ver que todo esté bien:

$ php artisan migrate

======
Tinker
======

Tinker es un poderoso REPL (Read - Eval - Print - Loop) para Laravel

REPL son programas que están a la espera de que se les escriba comandos para ser
ejecutados continuamente, de ahí el nombre de
lectura - evaluación - impresión - bucle.

Este paquete se instala por defecto en Laravel.

Es una línea de comando que permite hacer pruebas, para acceder a ella tipeamos:

$ php artisan tinker

y si accedimos correctamente nos muestra:

Psy Shell v0.9.12 (PHP 7.4.15 — cli) by Justin Hileman
>>>

Ahora, como prueba, vamos a crear una varible y vamos guardar un arreglo dentro
de ella que contenga datos relacionados al modelo User.php

Crear un nuevo usuario
======================

>>> $user = ['name'=>'Carlos Portrait','email'=>'cportrait@mail.com','password'=>bcrypt('123456')]

Le damos enter y nos muestra nuestro arreglo:

=> [
     "name" => "Carlos Portrait",
     "email" => "cportrait@mail.com",
     "password" => "$2y$10$2VueR70ZHixDULSxIqZM8uCDbmT1rImpZsirYLzKNpRi7UdBTcaxG",
   ]
>>>

bcrypt() es una función para encriptar contraseñas y es usada por defecto en
Laravel.

Ahora vamos a intentar guardar esos datos de nuestra varible dentro de la tabla
users de la base de datos:

Llamamos al namespace \App\User y luego usamos la función create() que le vamos
a pasar como parametro nuestra variable $user creada en el paso anterior:

>>> \App\User::create($user);

=> App\User {#3940
     name: "Carlos Portrait",
     email: "cportrait@mail.com",
     updated_at: "2021-05-04 16:51:15",
     created_at: "2021-05-04 16:51:15",
     id: 1,
   }
>>>

ó directamente le pasamos los datos en la función

$user = User::create(['name'=>'José Prieto','email'=>'jprieto@mail.com','password'=>bcrypt('123456')]);

Con esto el dato quedó guardado en la tabla users de la base de datos.

Si queremos consultar el valor de una variable creada lo hacemos de la siguiente
manera:

>>> $user

Consultar todos los usuarios o todos los registros de cualquier tabla
=====================================================================

>>> $users = \App\User::all();

Le damos enter:

=> Illuminate\Database\Eloquent\Collection {#3875
     all: [
       App\User {#4084
         id: 1,
         name: "Carlos Portrait",
         email: "cportrait@mail.com",
         email_verified_at: null,
         type: "member",
         created_at: "2021-05-04 16:51:15",
         updated_at: "2021-05-04 16:51:15",
       },
     ],
   }
>>>

ó

>>> $categories = \App\Category::all();

Consultar un registro específico por su clave foránea o id
===========================================================

>>> $user = User::find(1);

Otro ejemplo:

>>> $article = App\Article::find(1);

Lanzar una excepción si una búsqueda no tiene resultado
=======================================================

A veces, es posible que desee lanzar una excepción si no se encuentra un modelo.
Para hacer esto, puede usar el método firstOrFail()

>>> $model = User::findOrFail(3);

Illuminate/Database/Eloquent/ModelNotFoundException with message 'No query results for model [App/User] 3'

Actualización un dato de un objeto guardado
===========================================

Para actualizar un modelo, puede recuperarlo, cambiar un atributo y usar el
método save:

>>> $user = User::find(1);

ó

$tag = App\Tag::find(1);

>>> $user->email = 'john@foo.com';

>>> $user->save();

Borrar un registro guardado
===========================

Se usa la función delete() sobre el resultado de la búsqueda:

>>> $user = User::find(1);

>>> $user->delete();

Crear una categoría con el ejemplo del blog
===========================================

Desde la consola de Tinker creamos una variable y le decimos que vamos a crear
un nuevo registro y en el modelo que le indiquemos:

>>> $category = new App\Category();

Ahora, una Categoría contiene un campo nombre, entonces vamos a crear una nueva
categoría "Noticias":

>>> $category->name='Noticias';

Resultado:

=> "Noticias"

Ahora guardamos la operación que estamos realizando con:

>>> $category->save();

Resultado:

=> true

Ahora vamos a consultar la lista de categorías guardadas a ver si se guardo
de verdad la categoría noticias:

>>> $categories = \App\Category::all();

=> Illuminate\Database\Eloquent\Collection {#3155
     all: [
       App\Category {#3162
         id: 1,
         name: "Noticias",
         created_at: "2021-05-05 16:08:02",
         updated_at: "2021-05-05 16:08:02",
       },
     ],
   }

Crear un artículo con el ejemplo del blog
=========================================

>>> $article = new App\Article();

>>> $article->title='Noticia de última hora';

>>> $article->content='Contenido de la noticia';

>>> $article->category_id=1;

>>> $article->user_id=1;

>>> $article->save();

Crear una etiqueta con el ejemplo del blog
==========================================

>>> $tag = new App\Tag();

>>> $tag->name='Sucesos';

>>> $tag->save();

>>> $tags = \App\Tag::all();

Consultar cada valor de un objeto guardado
==========================================

>>> $article = App\Article::find(1);

=> App\Article {#4098
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
   }

>>> $article

=> App\Article {#4098
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
   }

>>> $article->id

=> 1

>>> $article->title

=> "Noticia de última hora"

>>> $article->tags

=> Illuminate\Database\Eloquent\Collection {#3161
     all: [],
   }

Luego de consultar los tags si volvemos a ejecutar $article nos sale el arreglo
de los tags:

>>> $article

=> App\Article {#3160
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 02:03:07",
     updated_at: "2021-05-06 02:03:07",
     tags: Illuminate\Database\Eloquent\Collection {#3161
       all: [],
     },
   }
>>>

Ejemplo de crear un objeto cuando la relación es muchos a muchos
================================================================

Para establecer una relación de muchos a muchos entre registros guardados se
usa la función attach().

En el siguiente ejemplo vamos a relacionar el tag con id=1 al artículo
consultado.

>>> $article->tags()->attach(1);

Se puede comprobar el registro guardado consultando la tabla article_tag.

=========================
Relaciones en los modelos
=========================

Por supuesto, las tablas de su base de datos probablemente estén relacionadas
entre sí. Por ejemplo, una publicación de blog puede tener muchos comentarios o
un pedido puede estar relacionado con el usuario que lo realizó. Eloquent
facilita la gestión y el trabajo con estas relaciones.

Laravel admite muchos tipos de relaciones:

-One To One (Uno a uno) su función es hasOne().

-One To Many (Uno a muchos) su función es hasMany() y la inversa es belongsTo().

-Many To Many (Muchos a muchos) su función es belongsToMany() y la inversa es
belongsToMany().

-Has Many Through (Tiene muchos) su función es hasManyThrough().

-Polymorphic Relations (Relaciones polimórficas)

-Many To Many Polymorphic Relations (Relaciones polimórficas de muchos a muchos)

Ejemplo de relación One To Many (Uno a muchos)
==============================================

Una categoría puede tener muchos artículos, entonces en el modelo Category.php
debemos crear una función pública que lleve por nombre el nombre de la tabla a
la cual se va a relacionar y en plural "articles".

En el return se usa la función hasMany y se le pasa la clase con la cuál se va a
establecer la relación App\Article.

public function articles()
{
    return $this->hasMany('App\Article');
}

Ejemplo plasmado en Category.php:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Category extends Model
{
    protected $table = "categories";
    protected $fillable = ['name'];

    public function articles()
    {
        return $this->hasMany('App\Article');
    }
}

Con esto ya estaría plasmada la relación por parte de las Categorías, pero se
requiere también hacerlo del lado inverso, es decir ahora hay que editar el
modelo Article.php

Creamos una función pública con el nombre de tabla a la cual se va a relacionar
pero en singular "category()" ya que recordemos que un artículo solo va a
pertenecer a una sola categoría.

En el return se usa la función belongsTo y se le pasa la clase con la cuál se
va a establecer la relación App\Category.

Ejemplo en Article.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }
}

También en este ejemplo vamor a relacionar los usuarios con los artículos.

Un usuario puede escribir varios artículos, y un artículo solo puede estar
relacionado con un solo usuario, entonces vamos a editar User.php agregando una
función pública articles() en plural como ya hemos comentado

public function articles()
{
    return $this->hasMany('App\Article');
}

El ejemplo completo de User.php sería:

<?php

namespace App;

use Illuminate\Notifications\Notifiable;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;

class User extends Authenticatable
{
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    /**
     * The attributes that should be cast to native types.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
    ];

    public function articles()
    {
        return $this->hasMany('App\Article');
    }
}

Ahora hay que hacer la relación inversa, por lo que vamos a editar Article.php
y agregamos la función user():

public function user()
{
    return $this->belongsTo('App\User');
}

Ejemplo completo:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }
}

Ahora, siguiendo con el ejemplo del blog, vamos a estableder una relación entre
las imágenes y los artículos, un artículo puede contener varias imágenes por lo
cual la relación es hasMany, entonces, vamos a Article.php y agregamos una
función publica images()

public function images()
{
    return $this->hasMany('App\Image');
}

Ejemplo completo en Article.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }

    public function images()
    {
        return $this->hasMany('App\Image');
    }
}

De igual forma hay que establecer la relación inversa en Image.php creando la
función pública article() en singular ya que las imágenes van relacionadas a un
solo artículo.

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Image extends Model
{
    protected $table = "images";
    protected $fillable = ['name','article_id'];

    public function article()
    {
        return $this->belongsTo('App\Article');
    }
}

Ejemplo de relación Many to Many o muchos a muchos
==================================================

Un artículo puede tener muchas etiquetas, por lo cuál la función que se crea se
referencia en plural, en Article.php.

y en el return se usaría la función belongsToMany()

public function tags()
{
    return $this->belongsToMany('App\Tag');
}

Ejemplo completo de Article.php:

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Article extends Model
{
    protected $table = "articles";
    protected $fillable = ['title','content','user_id','category_id'];

    public function category()
    {
        return $this->belongsTo('App\Category');
    }

    public function user()
    {
        return $this->belongsTo('App\User');
    }

    public function images()
    {
        return $this->hasMany('App\Image');
    }

    public function tags()
    {
        return $this->belongsToMany('App\Tag');
    }
}

Ahora hay que declarar la relación en Tag.php, se declara la función pública
articles() en plural ya que una etiqueta puede ser usada en muchos artículos.

Ejemplo completo de Tag.php

<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Tag extends Model
{
    protected $table = "tags";
    protected $fillable = ['name'];

    public function articles()
    {
        return $this->belongsToMany('App\Article');
    }
}

Ver las los datos relacionados de las tablas desde tinker
=========================================================

En este ejemplo, veremos los datos relacionados entre Artículos y Categorías.

>>> $article = App\Article::find(1);

=> App\Article {#3166
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 03:25:24",
     updated_at: "2021-05-06 03:25:24",
   }

>>> $article->category

=> App\Category {#3150
     id: 1,
     name: "Noticias",
     created_at: "2021-05-06 03:24:51",
     updated_at: "2021-05-06 03:24:51",
   }

Para ver los datos como un arreglo:

>>> $article->category->toArray()
=> [
     "id" => 1,
     "name" => "Noticias",
     "created_at" => "2021-05-06 03:24:51",
     "updated_at" => "2021-05-06 03:24:51",
   ]
>>>

Ver los datos del artículo:

>>> $article

=> App\Article {#3166
     id: 1,
     title: "Noticia de última hora",
     content: "Contenido de la noticia",
     user_id: 1,
     category_id: 1,
     created_at: "2021-05-06 03:25:24",
     updated_at: "2021-05-06 03:25:24",
     category: App\Category {#3150
       id: 1,
       name: "Noticias",
       created_at: "2021-05-06 03:24:51",
       updated_at: "2021-05-06 03:24:51",
     },
   }
>>>

============================================
Service Providers o Proveedores de servicios
============================================

Los proveedores de servicios son el lugar central de todas las aplicaciones de
arranque de Laravel. Su propia aplicación, así como todos los servicios
centrales de Laravel, se arrancan a través de proveedores de servicios.

Pero, ¿qué queremos decir con "bootstrapped"?  En general, nos referimos al
registro de cosas, incluido el registro de enlaces de contenedores de servicios,
detectores de eventos, middleware e incluso rutas.  Los proveedores de servicios
son el lugar central para configurar su aplicación.

Si abre el archivo config/app.php incluido con Laravel, verá una matriz de
proveedores. Estas son todas las clases de proveedores de servicios que se
cargarán para su aplicación. De forma predeterminada, un conjunto de proveedores
de servicios centrales de Laravel se enumeran en esta matriz. Estos proveedores
arrancan los componentes centrales de Laravel, como el mailer, la cola, la caché
y otros.  Muchos de estos proveedores son proveedores "diferidos", lo que
significa que no se cargarán en cada solicitud, sino solo cuando los servicios
que brindan sean realmente necesarios.

Escribiendo un proveedor de servicio
====================================

Todos los proveedores de servicios amplían la clase
Illuminate\Support\ServiceProvider.  La mayoría de los proveedores de servicios
contienen un registro y un método de inicio.  Dentro del método de registro,
solo debe vincular cosas en el contenedor de servicios.  Nunca debe intentar
registrar ningún detector de eventos, rutas o cualquier otra función dentro del
método de registro.

Artisan CLI puede generar un nuevo proveedor a través del comando make:provider

$ php artisan make:provider RiakServiceProvider

======================================
Creando un crud con Laravel desde cero
======================================

1) Crear el proyecto:

$ composer create-project --prefer-dist laravel/laravel laravel-5-crud "5.8.*"

2) Crear la base de datos y configurarla en el .env

3) Crear una migración con la tabla a la que le aplicaremos el crud:

$ php artisan make:migration add_students_table --create=students

4) Editar la migración agregando los campos que llevará la tabla.

5) Ejecutar la migración de la base de datos.

$ php artisan migrate

Esto nos crea las tablas (students, students_id_seq) en la base de datos,
chequear si esto se realizo correctamente.

6) Crear un modelo, debe tener el mismo nombre que la migración pero en plural:

$ php artisan make:model Student

7) Editar el modelo creado agregando el nombre de la table en la base de datos
y los campos fillables.

8) Usar la consola de tinker para probar si se guardan registros correctamente
en la base de datos.

9) Crear un una ruta, un controlador y una vista para el CRUD.

$ php artisan make:controller Student

10) Probar una consulta básica a los datos de la base de datos desde un
controlador.

11) Crear la ruta Route::resource('students','StudentController');

12) Escribir las funciones index, create, store, show, edit, update, delete en
el controlador.

==================
Laravel Collective
==================

El paquete HTML de Laravel Collective viene con un generador de HTML y FORM que
le permite manejar formularios fáciles de administrar en sus archivos blade, así
como un intrincado modelo de enlace a sus formularios.

1) Instalación

$ composer require "laravelcollective/html":"^5.8.0"

2) Agregue su nuevo proveedor a la matriz de proveedores de config/app.php:

'providers' => [
  // ...
  Collective\Html\HtmlServiceProvider::class,
  // ...
],

Finalmente, agregue dos alias de clase a la matriz de alias de config/app.php:

'aliases' => [
  // ...
    'Form' => Collective\Html\FormFacade::class,
    'Html' => Collective\Html\HtmlFacade::class,
  // ...
],

3) Agregua un formulario en tu vista:

{{ Form::open(['url' => 'foo/bar']) }}
    //
{{ Form::close() }}

Campo select
============

echo Form::select('size', ['L' => 'Large', 'S' => 'Small']);

Generating A Drop-Down List With Selected Default

Campo select con valor default
==============================

echo Form::select('size', ['L' => 'Large', 'S' => 'Small'], 'S');

Diferencias en la sintaxis del paquete
======================================

{!!  !!} equivale a <?php ?> y este no se muestra en el HTML.

{{ }} equivale a <?php echo ""; ?> y este si se muestra en el HTML.

Ejemplos:

{!! Form::open() !!}
{!! Form::close() !!}

Nos renderiza en el código fuente html:

<form method="POST" action="http://127.0.0.1:8000/students/create" accept-charset="UTF-8"><input name="_token" type="hidden" value="xxxxxxxxxxxxxxx">
</form>

================================
Aceptar datos vacíos en un campo
================================

Se usa el método nullable() en las migraciones, tal que:

public function up()
{
    Schema::create('students', function (Blueprint $table) {
        $table->bigIncrements('id');
        $table->string('first_name', 60)->nullable();
        $table->string('last_name', 60)->nullable();
        $table->string('identification_number', 60)->nullable();
        $table->timestamps();
    });
}

Con eso ya deja guardar un campo vacío.

====================================================
Validacion de errores y capturar errores en la vista
====================================================

La directiva @error puede usarse para verificar rápidamente si existen mensajes
de error de validación para un atributo dado. Dentro de una directiva @error,
puede hacer eco de la variable $ message para mostrar el mensaje de error:

En el controlador validamos que los campos del formulario sean requeridos:

public function store(Request $request)
{
    $request->validate([
        'first_name' => 'required',
        'last_name' => 'required',
        'identification_number' => 'required',
    ]);

    $student = new Student($request->all());
    $student->save();
    return redirect()->route('students.index')->with('info','Student was created!');
}

En la vista capturamos y recorremos todos los erroes que se activen:

@if(count($errors))
  <ul>
    @foreach($errors->all() as $error)
      <li>{{ $error }}</li>
    @endforeach
  </ul>
@endif

ó

@if ($errors->any())
  <p>Por favor corrige los siguientes errores</p>
  <ul>
    @foreach ($errors->all() as $error)
      <li>{{ $error }}</li>
    @endforeach
  </ul>
@endif

Con el método any() preguntamos si hay algún error en la vista. A través del
método all() obtenemos todos los errores.

Si guardamos el formulario con los campos vacíos nos dirá:

The first name field is required.
The last name field is required.
The identification number field is required.

Si queremos capturar cada error individualmente sera con:

@error('first_name')
  {{ $message }}
@enderror

@error('last_name')
  {{ $message }}
@enderror

Otras validaciones
==================

Validar que el campo sea requerido y tenga como mínimo 3 caracteres:

'first_name' => 'required|min:3',

The first name must be at least 3 characters.

-----

Nota cómo separamos cada regla de validación con una barra horizontal |.

Además si la regla requiere un argumento lo especificamos con :. Múltiples
argumentos se separan con ,. También podemos usar la sintaxis de arreglo:

$request->validate([
    'title' => ['required', 'min:3', 'unique:notes'],
]);

Incluso algunas reglas más complejas se pueden especificar a través de métodos o
una combinación de cadenas y métodos dentro de un arreglo:

use Illuminate\Validation\Rule;

$request->validate([
    'title' => ['required', 'max:200', Rule::unique('notes')],
]);

-----

Validar que el campo sea tipo email.

'email' => 'required|email|unique:clients',

The last name must be a valid email address.

-----

'email' => 'required|email|unique:clients',

Quiere decir que el email es requerido y sera único dentro de la tabla clients

-----

'register' => 'required_if:type,empresa'

En este caso el campo register solo es requerido cuando se haya seleccionado
‘empresa’ en el campo anterior dado que type es de tipo select, pero también
puede aplicar a un campo de texto:

'last_name' => 'required_if:first_name,pedro',

El campo de apellido es obligatorio cuando el nombre es pedro.

Mensajes personalizados para las validaciones
=============================================

Se agrega en un arreglo en la función validate, tal que:

,[
  'first_name.required' => 'El nombre es obligatorio',
  'last_name.required' => 'El apellido es obligatorio',
]);

Ejemplo:

public function store(Request $request)
{
    $request->validate([
        'first_name' => 'required',
        'last_name' => 'required',
        'identification_number' => 'required',
    ], [
        'first_name.required' => 'El nombre es obligatorio',
        'last_name.required' => 'El apellido es obligatorio',
    ]);

    $student = new Student($request->all());
    $student->save();
    return redirect()->route('students.index')->with('info','Student was created!');
}

Otro ejemplo:

$this->validate($request, [
      'active'      => 'boolean',
      'username'    => 'required|unique:users,username|alpha|max:25',
      'full_name'   => 'required',
      'email'       => 'required|email|max:255|unique:users',
      'password'    => 'required|confirmed|min:8|max:30',
      'permissions' => 'array|min:1',
      'roles'       => 'array|min:1',
      'country'     => 'required',
      'state'       => 'required',
      'city'        => 'required',
      'area_code'   => 'nullable|string'
], [
      'username.unique'    => 'El nombre de usuario ya esta registro.',
      'username.max'       => 'El nombre de usuario no debe ser mayor a 25 caracteres.',
      'username.alpha'     => 'El nombre de usuario no debe contener caracteres especiales o espacios.',
      'full_name.required' => 'El nombre completo es obligatorio.',
      'email.email'        => 'El correo electrónico no es valido.',
      'country.required'   => 'El campo pais es obligatorio.',
      'state.required'     => 'El campo estado es obligatorio.',
      'city.required'      => 'El campo ciudad es obligatorio.',
      'permissions.min'    => 'El usuario debe tener almenos un permiso.',
      'roles.min'          => 'El usuario debe tener almenos un rol.',
]);

Más validaciones en la documentación oficial:

https://laravel.com/docs/8.x/validation#rule-max

====================
La función compact()
====================

La función compact se usa ampliamente en Laravel, no confunda esto con una
función de Laravel porque no lo es, esta es una función PHP. Entonces with() le
permite pasar variables a una vista y compact() crea una matriz a partir de
variables existentes que se le dan como argumentos de cadena.

Ejemplo:

$user = User::all();
return view('index', compact('user'));

================================================
Ejemplo de relación entre categorías y artículos
================================================

Una categoría puede tener varios artículos asociados, pero un artículo solo
puede estar asociado a una categoría, por lo tanto la relación

1) Generar una nueva migración y crear una tabla llamada categories:

$ php artisan make:migration add_categories_table --create=categories

2) Editar la migración y agregar los campos necesarios.

3) Generar una nueva migración y crear una tabla llamada articles:

$ php artisan make:migration add_articles_table --create=articles

4) Editar la migración y agregar los campos necesarios, incluyendo los campos
para las foreign keys.

5) Crear un modelo para las categorías:

$ php artisan make:model Category

6) Editar el modelo creado agregando los campos fillables y la función que
establece la relacion con los artículos.

7) Crear un modelo para los artículos:

$ php artisan make:model Article

8) Editar el modelo creado agregando los campos fillables inlcuyendo el campo
que relaciona el artículo con una categoría y la función que establece la
relacion con la categoría.

Para comprobar que las relaciones estén bien, se recomienda probar desde Tinker:

Crear categorías desde la consola de Tinker
===========================================

$category = new App\Category();

$category->name='Noticias';

$category->save();

$categories = \App\Category::all();

Crear artículos desde la consola de Tinker
==========================================

$article = new App\Article();

$article->title='Noticia de última hora';

$article->content='Contenido de la noticia';

$article->category_id=1;

$article->save();

$articles = \App\Article::all();

Ejemplo completo en:

-https://github.com/argenisosorio/laravel-5-crud/tree/relationships

=================
El método pluck()
=================

El método pluck recupera todos los valores de una clave determinada:

$collection = collect([
    ['product_id' => 'prod-100', 'name' => 'Desk'],
    ['product_id' => 'prod-200', 'name' => 'Chair'],
]);

$plucked = $collection->pluck('name');

$plucked->all();

// ['Desk', 'Chair']

====================================
Actualizar lista de paquetes de node
====================================

Este comando actualizará todos los paquetes listados a la última versión.

$ npm update